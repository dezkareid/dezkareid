prompt = "# Phase Prompt Template\n\n> **Note:** Planning methodology is in `agents/gsd-planner.md`.\n> This template defines the PLAN.md output format that the agent produces.\n\nTemplate for `.planning/phases/XX-name/{phase}-{plan}-PLAN.md` - executable phase plans optimized for parallel execution.\n\n**Naming:** Use `{phase}-{plan}-PLAN.md` format (e.g., `01-02-PLAN.md` for Phase 1, Plan 2)\n\n---\n\n## File Template\n\n```markdown\n---\nphase: XX-name\nplan: NN\ntype: execute\nwave: N                     # Execution wave (1, 2, 3...). Pre-computed at plan time.\ndepends_on: []              # Plan IDs this plan requires (e.g., [\"01-01\"]).\nfiles_modified: []          # Files this plan modifies.\nautonomous: true            # false if plan has checkpoints requiring user interaction\nuser_setup: []              # Human-required setup Claude cannot automate (see below)\n\n# Goal-backward verification (derived during planning, verified after execution)\nmust_haves:\n  truths: []                # Observable behaviors that must be true for goal achievement\n  artifacts: []             # Files that must exist with real implementation\n  key_links: []             # Critical connections between artifacts\n---\n\n<objective>\n[What this plan accomplishes]\n\nPurpose: [Why this matters for the project]\nOutput: [What artifacts will be created]\n</objective>\n\n<execution_context>\n@./.gemini/get-shit-done/workflows/execute-plan.md\n@./.gemini/get-shit-done/templates/summary.md\n[If plan contains checkpoint tasks (type=\"checkpoint:*\"), add:]\n@./.gemini/get-shit-done/references/checkpoints.md\n</execution_context>\n\n<context>\n@.planning/PROJECT.md\n@.planning/ROADMAP.md\n@.planning/STATE.md\n\n# Only reference prior plan SUMMARYs if genuinely needed:\n# - This plan uses types/exports from prior plan\n# - Prior plan made decision that affects this plan\n# Do NOT reflexively chain: Plan 02 refs 01, Plan 03 refs 02...\n\n[Relevant source files:]\n@src/path/to/relevant.ts\n</context>\n\n<tasks>\n\n<task type=\"auto\">\n  <name>Task 1: [Action-oriented name]</name>\n  <files>path/to/file.ext, another/file.ext</files>\n  <action>[Specific implementation - what to do, how to do it, what to avoid and WHY]</action>\n  <verify>[Command or check to prove it worked]</verify>\n  <done>[Measurable acceptance criteria]</done>\n</task>\n\n<task type=\"auto\">\n  <name>Task 2: [Action-oriented name]</name>\n  <files>path/to/file.ext</files>\n  <action>[Specific implementation]</action>\n  <verify>[Command or check]</verify>\n  <done>[Acceptance criteria]</done>\n</task>\n\n<!-- For checkpoint task examples and patterns, see @./.gemini/get-shit-done/references/checkpoints.md -->\n<!-- Key rule: Claude starts dev server BEFORE human-verify checkpoints. User only visits URLs. -->\n\n<task type=\"checkpoint:decision\" gate=\"blocking\">\n  <decision>[What needs deciding]</decision>\n  <context>[Why this decision matters]</context>\n  <options>\n    <option id=\"option-a\"><name>[Name]</name><pros>[Benefits]</pros><cons>[Tradeoffs]</cons></option>\n    <option id=\"option-b\"><name>[Name]</name><pros>[Benefits]</pros><cons>[Tradeoffs]</cons></option>\n  </options>\n  <resume-signal>Select: option-a or option-b</resume-signal>\n</task>\n\n<task type=\"checkpoint:human-verify\" gate=\"blocking\">\n  <what-built>[What Claude built] - server running at [URL]</what-built>\n  <how-to-verify>Visit [URL] and verify: [visual checks only, NO CLI commands]</how-to-verify>\n  <resume-signal>Type \"approved\" or describe issues</resume-signal>\n</task>\n\n</tasks>\n\n<verification>\nBefore declaring plan complete:\n- [ ] [Specific test command]\n- [ ] [Build/type check passes]\n- [ ] [Behavior verification]\n</verification>\n\n<success_criteria>\n\n- All tasks completed\n- All verification checks pass\n- No errors or warnings introduced\n- [Plan-specific criteria]\n  </success_criteria>\n\n<output>\nAfter completion, create `.planning/phases/XX-name/{phase}-{plan}-SUMMARY.md`\n</output>\n```\n\n---\n\n## Frontmatter Fields\n\n| Field | Required | Purpose |\n|-------|----------|---------|\n| `phase` | Yes | Phase identifier (e.g., `01-foundation`) |\n| `plan` | Yes | Plan number within phase (e.g., `01`, `02`) |\n| `type` | Yes | Always `execute` for standard plans, `tdd` for TDD plans |\n| `wave` | Yes | Execution wave number (1, 2, 3...). Pre-computed at plan time. |\n| `depends_on` | Yes | Array of plan IDs this plan requires. |\n| `files_modified` | Yes | Files this plan touches. |\n| `autonomous` | Yes | `true` if no checkpoints, `false` if has checkpoints |\n| `user_setup` | No | Array of human-required setup items (external services) |\n| `must_haves` | Yes | Goal-backward verification criteria (see below) |\n\n**Wave is pre-computed:** Wave numbers are assigned during `/gsd:plan-phase`. Execute-phase reads `wave` directly from frontmatter and groups plans by wave number. No runtime dependency analysis needed.\n\n**Must-haves enable verification:** The `must_haves` field carries goal-backward requirements from planning to execution. After all plans complete, execute-phase spawns a verification subagent that checks these criteria against the actual codebase.\n\n---\n\n## Parallel vs Sequential\n\n<parallel_examples>\n\n**Wave 1 candidates (parallel):**\n\n```yaml\n# Plan 01 - User feature\nwave: 1\ndepends_on: []\nfiles_modified: [src/models/user.ts, src/api/users.ts]\nautonomous: true\n\n# Plan 02 - Product feature (no overlap with Plan 01)\nwave: 1\ndepends_on: []\nfiles_modified: [src/models/product.ts, src/api/products.ts]\nautonomous: true\n\n# Plan 03 - Order feature (no overlap)\nwave: 1\ndepends_on: []\nfiles_modified: [src/models/order.ts, src/api/orders.ts]\nautonomous: true\n```\n\nAll three run in parallel (Wave 1) - no dependencies, no file conflicts.\n\n**Sequential (genuine dependency):**\n\n```yaml\n# Plan 01 - Auth foundation\nwave: 1\ndepends_on: []\nfiles_modified: [src/lib/auth.ts, src/middleware/auth.ts]\nautonomous: true\n\n# Plan 02 - Protected features (needs auth)\nwave: 2\ndepends_on: [\"01\"]\nfiles_modified: [src/features/dashboard.ts]\nautonomous: true\n```\n\nPlan 02 in Wave 2 waits for Plan 01 in Wave 1 - genuine dependency on auth types/middleware.\n\n**Checkpoint plan:**\n\n```yaml\n# Plan 03 - UI with verification\nwave: 3\ndepends_on: [\"01\", \"02\"]\nfiles_modified: [src/components/Dashboard.tsx]\nautonomous: false  # Has checkpoint:human-verify\n```\n\nWave 3 runs after Waves 1 and 2. Pauses at checkpoint, orchestrator presents to user, resumes on approval.\n\n</parallel_examples>\n\n---\n\n## Context Section\n\n**Parallel-aware context:**\n\n```markdown\n<context>\n@.planning/PROJECT.md\n@.planning/ROADMAP.md\n@.planning/STATE.md\n\n# Only include SUMMARY refs if genuinely needed:\n# - This plan imports types from prior plan\n# - Prior plan made decision affecting this plan\n# - Prior plan's output is input to this plan\n#\n# Independent plans need NO prior SUMMARY references.\n# Do NOT reflexively chain: 02 refs 01, 03 refs 02...\n\n@src/relevant/source.ts\n</context>\n```\n\n**Bad pattern (creates false dependencies):**\n```markdown\n<context>\n@.planning/phases/03-features/03-01-SUMMARY.md  # Just because it's earlier\n@.planning/phases/03-features/03-02-SUMMARY.md  # Reflexive chaining\n</context>\n```\n\n---\n\n## Scope Guidance\n\n**Plan sizing:**\n\n- 2-3 tasks per plan\n- ~50% context usage maximum\n- Complex phases: Multiple focused plans, not one large plan\n\n**When to split:**\n\n- Different subsystems (auth vs API vs UI)\n- >3 tasks\n- Risk of context overflow\n- TDD candidates - separate plans\n\n**Vertical slices preferred:**\n\n```\nPREFER: Plan 01 = User (model + API + UI)\n        Plan 02 = Product (model + API + UI)\n\nAVOID:  Plan 01 = All models\n        Plan 02 = All APIs\n        Plan 03 = All UIs\n```\n\n---\n\n## TDD Plans\n\nTDD features get dedicated plans with `type: tdd`.\n\n**Heuristic:** Can you write `expect(fn(input)).toBe(output)` before writing `fn`?\n→ Yes: Create a TDD plan\n→ No: Standard task in standard plan\n\nSee `./.gemini/get-shit-done/references/tdd.md` for TDD plan structure.\n\n---\n\n## Task Types\n\n| Type | Use For | Autonomy |\n|------|---------|----------|\n| `auto` | Everything Claude can do independently | Fully autonomous |\n| `checkpoint:human-verify` | Visual/functional verification | Pauses, returns to orchestrator |\n| `checkpoint:decision` | Implementation choices | Pauses, returns to orchestrator |\n| `checkpoint:human-action` | Truly unavoidable manual steps (rare) | Pauses, returns to orchestrator |\n\n**Checkpoint behavior in parallel execution:**\n- Plan runs until checkpoint\n- Agent returns with checkpoint details + agent_id\n- Orchestrator presents to user\n- User responds\n- Orchestrator resumes agent with `resume: agent_id`\n\n---\n\n## Examples\n\n**Autonomous parallel plan:**\n\n```markdown\n---\nphase: 03-features\nplan: 01\ntype: execute\nwave: 1\ndepends_on: []\nfiles_modified: [src/features/user/model.ts, src/features/user/api.ts, src/features/user/UserList.tsx]\nautonomous: true\n---\n\n<objective>\nImplement complete User feature as vertical slice.\n\nPurpose: Self-contained user management that can run parallel to other features.\nOutput: User model, API endpoints, and UI components.\n</objective>\n\n<context>\n@.planning/PROJECT.md\n@.planning/ROADMAP.md\n@.planning/STATE.md\n</context>\n\n<tasks>\n<task type=\"auto\">\n  <name>Task 1: Create User model</name>\n  <files>src/features/user/model.ts</files>\n  <action>Define User type with id, email, name, createdAt. Export TypeScript interface.</action>\n  <verify>tsc --noEmit passes</verify>\n  <done>User type exported and usable</done>\n</task>\n\n<task type=\"auto\">\n  <name>Task 2: Create User API endpoints</name>\n  <files>src/features/user/api.ts</files>\n  <action>GET /users (list), GET /users/:id (single), POST /users (create). Use User type from model.</action>\n  <verify>curl tests pass for all endpoints</verify>\n  <done>All CRUD operations work</done>\n</task>\n</tasks>\n\n<verification>\n- [ ] npm run build succeeds\n- [ ] API endpoints respond correctly\n</verification>\n\n<success_criteria>\n- All tasks completed\n- User feature works end-to-end\n</success_criteria>\n\n<output>\nAfter completion, create `.planning/phases/03-features/03-01-SUMMARY.md`\n</output>\n```\n\n**Plan with checkpoint (non-autonomous):**\n\n```markdown\n---\nphase: 03-features\nplan: 03\ntype: execute\nwave: 2\ndepends_on: [\"03-01\", \"03-02\"]\nfiles_modified: [src/components/Dashboard.tsx]\nautonomous: false\n---\n\n<objective>\nBuild dashboard with visual verification.\n\nPurpose: Integrate user and product features into unified view.\nOutput: Working dashboard component.\n</objective>\n\n<execution_context>\n@./.gemini/get-shit-done/workflows/execute-plan.md\n@./.gemini/get-shit-done/templates/summary.md\n@./.gemini/get-shit-done/references/checkpoints.md\n</execution_context>\n\n<context>\n@.planning/PROJECT.md\n@.planning/ROADMAP.md\n@.planning/phases/03-features/03-01-SUMMARY.md\n@.planning/phases/03-features/03-02-SUMMARY.md\n</context>\n\n<tasks>\n<task type=\"auto\">\n  <name>Task 1: Build Dashboard layout</name>\n  <files>src/components/Dashboard.tsx</files>\n  <action>Create responsive grid with UserList and ProductList components. Use Tailwind for styling.</action>\n  <verify>npm run build succeeds</verify>\n  <done>Dashboard renders without errors</done>\n</task>\n\n<!-- Checkpoint pattern: Claude starts server, user visits URL. See checkpoints.md for full patterns. -->\n<task type=\"auto\">\n  <name>Start dev server</name>\n  <action>Run `npm run dev` in background, wait for ready</action>\n  <verify>curl localhost:3000 returns 200</verify>\n</task>\n\n<task type=\"checkpoint:human-verify\" gate=\"blocking\">\n  <what-built>Dashboard - server at http://localhost:3000</what-built>\n  <how-to-verify>Visit localhost:3000/dashboard. Check: desktop grid, mobile stack, no scroll issues.</how-to-verify>\n  <resume-signal>Type \"approved\" or describe issues</resume-signal>\n</task>\n</tasks>\n\n<verification>\n- [ ] npm run build succeeds\n- [ ] Visual verification passed\n</verification>\n\n<success_criteria>\n- All tasks completed\n- User approved visual layout\n</success_criteria>\n\n<output>\nAfter completion, create `.planning/phases/03-features/03-03-SUMMARY.md`\n</output>\n```\n\n---\n\n## Anti-Patterns\n\n**Bad: Reflexive dependency chaining**\n```yaml\ndepends_on: [\"03-01\"]  # Just because 01 comes before 02\n```\n\n**Bad: Horizontal layer grouping**\n```\nPlan 01: All models\nPlan 02: All APIs (depends on 01)\nPlan 03: All UIs (depends on 02)\n```\n\n**Bad: Missing autonomy flag**\n```yaml\n# Has checkpoint but no autonomous: false\ndepends_on: []\nfiles_modified: [...]\n# autonomous: ???  <- Missing!\n```\n\n**Bad: Vague tasks**\n```xml\n<task type=\"auto\">\n  <name>Set up authentication</name>\n  <action>Add auth to the app</action>\n</task>\n```\n\n---\n\n## Guidelines\n\n- Always use XML structure for Claude parsing\n- Include `wave`, `depends_on`, `files_modified`, `autonomous` in every plan\n- Prefer vertical slices over horizontal layers\n- Only reference prior SUMMARYs when genuinely needed\n- Group checkpoints with related auto tasks in same plan\n- 2-3 tasks per plan, ~50% context max\n\n---\n\n## User Setup (External Services)\n\nWhen a plan introduces external services requiring human configuration, declare in frontmatter:\n\n```yaml\nuser_setup:\n  - service: stripe\n    why: \"Payment processing requires API keys\"\n    env_vars:\n      - name: STRIPE_SECRET_KEY\n        source: \"Stripe Dashboard → Developers → API keys → Secret key\"\n      - name: STRIPE_WEBHOOK_SECRET\n        source: \"Stripe Dashboard → Developers → Webhooks → Signing secret\"\n    dashboard_config:\n      - task: \"Create webhook endpoint\"\n        location: \"Stripe Dashboard → Developers → Webhooks → Add endpoint\"\n        details: \"URL: https://[your-domain]/api/webhooks/stripe\"\n    local_dev:\n      - \"stripe listen --forward-to localhost:3000/api/webhooks/stripe\"\n```\n\n**The automation-first rule:** `user_setup` contains ONLY what Claude literally cannot do:\n- Account creation (requires human signup)\n- Secret retrieval (requires dashboard access)\n- Dashboard configuration (requires human in browser)\n\n**NOT included:** Package installs, code changes, file creation, CLI commands Claude can run.\n\n**Result:** Execute-plan generates `{phase}-USER-SETUP.md` with checklist for the user.\n\nSee `./.gemini/get-shit-done/templates/user-setup.md` for full schema and examples\n\n---\n\n## Must-Haves (Goal-Backward Verification)\n\nThe `must_haves` field defines what must be TRUE for the phase goal to be achieved. Derived during planning, verified after execution.\n\n**Structure:**\n\n```yaml\nmust_haves:\n  truths:\n    - \"User can see existing messages\"\n    - \"User can send a message\"\n    - \"Messages persist across refresh\"\n  artifacts:\n    - path: \"src/components/Chat.tsx\"\n      provides: \"Message list rendering\"\n      min_lines: 30\n    - path: \"src/app/api/chat/route.ts\"\n      provides: \"Message CRUD operations\"\n      exports: [\"GET\", \"POST\"]\n    - path: \"prisma/schema.prisma\"\n      provides: \"Message model\"\n      contains: \"model Message\"\n  key_links:\n    - from: \"src/components/Chat.tsx\"\n      to: \"/api/chat\"\n      via: \"fetch in useEffect\"\n      pattern: \"fetch.*api/chat\"\n    - from: \"src/app/api/chat/route.ts\"\n      to: \"prisma.message\"\n      via: \"database query\"\n      pattern: \"prisma\\\\.message\\\\.(find|create)\"\n```\n\n**Field descriptions:**\n\n| Field | Purpose |\n|-------|---------|\n| `truths` | Observable behaviors from user perspective. Each must be testable. |\n| `artifacts` | Files that must exist with real implementation. |\n| `artifacts[].path` | File path relative to project root. |\n| `artifacts[].provides` | What this artifact delivers. |\n| `artifacts[].min_lines` | Optional. Minimum lines to be considered substantive. |\n| `artifacts[].exports` | Optional. Expected exports to verify. |\n| `artifacts[].contains` | Optional. Pattern that must exist in file. |\n| `key_links` | Critical connections between artifacts. |\n| `key_links[].from` | Source artifact. |\n| `key_links[].to` | Target artifact or endpoint. |\n| `key_links[].via` | How they connect (description). |\n| `key_links[].pattern` | Optional. Regex to verify connection exists. |\n\n**Why this matters:**\n\nTask completion ≠ Goal achievement. A task \"create chat component\" can complete by creating a placeholder. The `must_haves` field captures what must actually work, enabling verification to catch gaps before they compound.\n\n**Verification flow:**\n\n1. Plan-phase derives must_haves from phase goal (goal-backward)\n2. Must_haves written to PLAN.md frontmatter\n3. Execute-phase runs all plans\n4. Verification subagent checks must_haves against codebase\n5. Gaps found → fix plans created → execute → re-verify\n6. All must_haves pass → phase complete\n\nSee `./.gemini/get-shit-done/workflows/verify-phase.md` for verification logic.\n"
