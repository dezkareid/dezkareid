prompt = "<purpose>\nExecute a phase prompt (PLAN.md) and create the outcome summary (SUMMARY.md).\n</purpose>\n\n<required_reading>\nRead STATE.md before any operation to load project context.\nRead config.json for planning behavior settings.\n\n@./.gemini/get-shit-done/references/git-integration.md\n</required_reading>\n\n<process>\n\n<step name=\"init_context\" priority=\"first\">\nLoad execution context (uses `init execute-phase` for full context, including file contents):\n\n```bash\nINIT=$(node ./.gemini/get-shit-done/bin/gsd-tools.js init execute-phase \"${PHASE}\" --include state,config)\n```\n\nExtract from init JSON: `executor_model`, `commit_docs`, `phase_dir`, `phase_number`, `plans`, `summaries`, `incomplete_plans`.\n\n**File contents (from --include):** `state_content`, `config_content`. Access with:\n```bash\nSTATE_CONTENT=$(echo \"$INIT\" | jq -r '.state_content // empty')\nCONFIG_CONTENT=$(echo \"$INIT\" | jq -r '.config_content // empty')\n```\n\nIf `.planning/` missing: error.\n</step>\n\n<step name=\"identify_plan\">\n```bash\n# Use plans/summaries from INIT JSON, or list files\nls .planning/phases/XX-name/*-PLAN.md 2>/dev/null | sort\nls .planning/phases/XX-name/*-SUMMARY.md 2>/dev/null | sort\n```\n\nFind first PLAN without matching SUMMARY. Decimal phases supported (`01.1-hotfix/`):\n\n```bash\nPHASE=$(echo \"$PLAN_PATH\" | grep -oE '[0-9]+(\\.[0-9]+)?-[0-9]+')\n# config_content already loaded via --include config in init_context\n```\n\n<if mode=\"yolo\">\nAuto-approve: `⚡ Execute {phase}-{plan}-PLAN.md [Plan X of Y for Phase Z]` → parse_segments.\n</if>\n\n<if mode=\"interactive\" OR=\"custom with gates.execute_next_plan true\">\nPresent plan identification, wait for confirmation.\n</if>\n</step>\n\n<step name=\"record_start_time\">\n```bash\nPLAN_START_TIME=$(date -u +\"%Y-%m-%dT%H:%M:%SZ\")\nPLAN_START_EPOCH=$(date +%s)\n```\n</step>\n\n<step name=\"parse_segments\">\n```bash\ngrep -n \"type=\\\"checkpoint\" .planning/phases/XX-name/{phase}-{plan}-PLAN.md\n```\n\n**Routing by checkpoint type:**\n\n| Checkpoints | Pattern | Execution |\n|-------------|---------|-----------|\n| None | A (autonomous) | Single subagent: full plan + SUMMARY + commit |\n| Verify-only | B (segmented) | Segments between checkpoints. After none/human-verify → SUBAGENT. After decision/human-action → MAIN |\n| Decision | C (main) | Execute entirely in main context |\n\n**Pattern A:** init_agent_tracking → spawn Task(subagent_type=\"gsd-executor\", model=executor_model) with prompt: execute plan at [path], autonomous, all tasks + SUMMARY + commit, follow deviation/auth rules, report: plan name, tasks, SUMMARY path, commit hash → track agent_id → wait → update tracking → report.\n\n**Pattern B:** Execute segment-by-segment. Autonomous segments: spawn subagent for assigned tasks only (no SUMMARY/commit). Checkpoints: main context. After all segments: aggregate, create SUMMARY, commit. See segment_execution.\n\n**Pattern C:** Execute in main using standard flow (step name=\"execute\").\n\nFresh context per subagent preserves peak quality. Main context stays lean.\n</step>\n\n<step name=\"init_agent_tracking\">\n```bash\nif [ ! -f .planning/agent-history.json ]; then\n  echo '{\"version\":\"1.0\",\"max_entries\":50,\"entries\":[]}' > .planning/agent-history.json\nfi\nrm -f .planning/current-agent-id.txt\nif [ -f .planning/current-agent-id.txt ]; then\n  INTERRUPTED_ID=$(cat .planning/current-agent-id.txt)\n  echo \"Found interrupted agent: $INTERRUPTED_ID\"\nfi\n```\n\nIf interrupted: ask user to resume (Task `resume` parameter) or start fresh.\n\n**Tracking protocol:** On spawn: write agent_id to `current-agent-id.txt`, append to agent-history.json: `{\"agent_id\":\"[id]\",\"task_description\":\"[desc]\",\"phase\":\"[phase]\",\"plan\":\"[plan]\",\"segment\":[num|null],\"timestamp\":\"[ISO]\",\"status\":\"spawned\",\"completion_timestamp\":null}`. On completion: status → \"completed\", set completion_timestamp, delete current-agent-id.txt. Prune: if entries > max_entries, remove oldest \"completed\" (never \"spawned\").\n\nRun for Pattern A/B before spawning. Pattern C: skip.\n</step>\n\n<step name=\"segment_execution\">\nPattern B only (verify-only checkpoints). Skip for A/C.\n\n1. Parse segment map: checkpoint locations and types\n2. Per segment:\n   - Subagent route: spawn gsd-executor for assigned tasks only. Prompt: task range, plan path, read full plan for context, execute assigned tasks, track deviations, NO SUMMARY/commit. Track via agent protocol.\n   - Main route: execute tasks using standard flow (step name=\"execute\")\n3. After ALL segments: aggregate files/deviations/decisions → create SUMMARY.md → commit → self-check:\n   - Verify key-files.created exist on disk with `[ -f ]`\n   - Check `git log --oneline --all --grep=\"{phase}-{plan}\"` returns ≥1 commit\n   - Append `## Self-Check: PASSED` or `## Self-Check: FAILED` to SUMMARY\n\n   **Known Claude Code bug (classifyHandoffIfNeeded):** If any segment agent reports \"failed\" with `classifyHandoffIfNeeded is not defined`, this is a Claude Code runtime bug — not a real failure. Run spot-checks; if they pass, treat as successful.\n\n\n\n\n</step>\n\n<step name=\"load_prompt\">\n```bash\ncat .planning/phases/XX-name/{phase}-{plan}-PLAN.md\n```\nThis IS the execution instructions. Follow exactly. If plan references CONTEXT.md: honor user's vision throughout.\n</step>\n\n<step name=\"previous_phase_check\">\n```bash\nls .planning/phases/*/SUMMARY.md 2>/dev/null | sort -r | head -2 | tail -1\n```\nIf previous SUMMARY has unresolved \"Issues Encountered\" or \"Next Phase Readiness\" blockers: AskUserQuestion(header=\"Previous Issues\", options: \"Proceed anyway\" | \"Address first\" | \"Review previous\").\n</step>\n\n<step name=\"execute\">\nDeviations are normal — handle via rules below.\n\n1. Read @context files from prompt\n2. Per task:\n   - `type=\"auto\"`: if `tdd=\"true\"` → TDD execution. Implement with deviation rules + auth gates. Verify done criteria. Commit (see task_commit). Track hash for Summary.\n   - `type=\"checkpoint:*\"`: STOP → checkpoint_protocol → wait for user → continue only after confirmation.\n3. Run `<verification>` checks\n4. Confirm `<success_criteria>` met\n5. Document deviations in Summary\n</step>\n\n<authentication_gates>\n\n## Authentication Gates\n\nAuth errors during execution are NOT failures — they're expected interaction points.\n\n**Indicators:** \"Not authenticated\", \"Unauthorized\", 401/403, \"Please run {tool} login\", \"Set {ENV_VAR}\"\n\n**Protocol:**\n1. Recognize auth gate (not a bug)\n2. STOP task execution\n3. Create dynamic checkpoint:human-action with exact auth steps\n4. Wait for user to authenticate\n5. Verify credentials work\n6. Retry original task\n7. Continue normally\n\n**Example:** `vercel --yes` → \"Not authenticated\" → checkpoint asking user to `vercel login` → verify with `vercel whoami` → retry deploy → continue\n\n**In Summary:** Document as normal flow under \"## Authentication Gates\", not as deviations.\n\n</authentication_gates>\n\n<deviation_rules>\n\n## Deviation Rules\n\nYou WILL discover unplanned work. Apply automatically, track all for Summary.\n\n| Rule | Trigger | Action | Permission |\n|------|---------|--------|------------|\n| **1: Bug** | Broken behavior, errors, wrong queries, type errors, security vulns, race conditions, leaks | Fix → test → verify → track `[Rule 1 - Bug]` | Auto |\n| **2: Missing Critical** | Missing essentials: error handling, validation, auth, CSRF/CORS, rate limiting, indexes, logging | Add → test → verify → track `[Rule 2 - Missing Critical]` | Auto |\n| **3: Blocking** | Prevents completion: missing deps, wrong types, broken imports, missing env/config/files, circular deps | Fix blocker → verify proceeds → track `[Rule 3 - Blocking]` | Auto |\n| **4: Architectural** | Structural change: new DB table, schema change, new service, switching libs, breaking API, new infra | STOP → present decision (below) → track `[Rule 4 - Architectural]` | Ask user |\n\n**Rule 4 format:**\n```\n⚠️ Architectural Decision Needed\n\nCurrent task: [task name]\nDiscovery: [what prompted this]\nProposed change: [modification]\nWhy needed: [rationale]\nImpact: [what this affects]\nAlternatives: [other approaches]\n\nProceed with proposed change? (yes / different approach / defer)\n```\n\n**Priority:** Rule 4 (STOP) > Rules 1-3 (auto) > unsure → Rule 4\n**Edge cases:** missing validation → R2 | null crash → R1 | new table → R4 | new column → R1/2\n**Heuristic:** Affects correctness/security/completion? → R1-3. Maybe? → R4.\n\n</deviation_rules>\n\n<deviation_documentation>\n\n## Documenting Deviations\n\nSummary MUST include deviations section. None? → `## Deviations from Plan\\n\\nNone - plan executed exactly as written.`\n\nPer deviation: **[Rule N - Category] Title** — Found during: Task X | Issue | Fix | Files modified | Verification | Commit hash\n\nEnd with: **Total deviations:** N auto-fixed (breakdown). **Impact:** assessment.\n\n</deviation_documentation>\n\n<tdd_plan_execution>\n## TDD Execution\n\nFor `type: tdd` plans — RED-GREEN-REFACTOR:\n\n1. **Infrastructure** (first TDD plan only): detect project, install framework, config, verify empty suite\n2. **RED:** Read `<behavior>` → failing test(s) → run (MUST fail) → commit: `test({phase}-{plan}): add failing test for [feature]`\n3. **GREEN:** Read `<implementation>` → minimal code → run (MUST pass) → commit: `feat({phase}-{plan}): implement [feature]`\n4. **REFACTOR:** Clean up → tests MUST pass → commit: `refactor({phase}-{plan}): clean up [feature]`\n\nErrors: RED doesn't fail → investigate test/existing feature. GREEN doesn't pass → debug, iterate. REFACTOR breaks → undo.\n\nSee `./.gemini/get-shit-done/references/tdd.md` for structure.\n</tdd_plan_execution>\n\n<task_commit>\n## Task Commit Protocol\n\nAfter each task (verification passed, done criteria met), commit immediately.\n\n**1. Check:** `git status --short`\n\n**2. Stage individually** (NEVER `git add .` or `git add -A`):\n```bash\ngit add src/api/auth.ts\ngit add src/types/user.ts\n```\n\n**3. Commit type:**\n\n| Type | When | Example |\n|------|------|---------|\n| `feat` | New functionality | feat(08-02): create user registration endpoint |\n| `fix` | Bug fix | fix(08-02): correct email validation regex |\n| `test` | Test-only (TDD RED) | test(08-02): add failing test for password hashing |\n| `refactor` | No behavior change (TDD REFACTOR) | refactor(08-02): extract validation to helper |\n| `perf` | Performance | perf(08-02): add database index |\n| `docs` | Documentation | docs(08-02): add API docs |\n| `style` | Formatting | style(08-02): format auth module |\n| `chore` | Config/deps | chore(08-02): add bcrypt dependency |\n\n**4. Format:** `{type}({phase}-{plan}): {description}` with bullet points for key changes.\n\n**5. Record hash:**\n```bash\nTASK_COMMIT=$(git rev-parse --short HEAD)\nTASK_COMMITS+=(\"Task ${TASK_NUM}: ${TASK_COMMIT}\")\n```\n\n</task_commit>\n\n<step name=\"checkpoint_protocol\">\nOn `type=\"checkpoint:*\"`: automate everything possible first. Checkpoints are for verification/decisions only.\n\nDisplay: `CHECKPOINT: [Type]` box → Progress {X}/{Y} → Task name → type-specific content → `YOUR ACTION: [signal]`\n\n| Type | Content | Resume signal |\n|------|---------|---------------|\n| human-verify (90%) | What was built + verification steps (commands/URLs) | \"approved\" or describe issues |\n| decision (9%) | Decision needed + context + options with pros/cons | \"Select: option-id\" |\n| human-action (1%) | What was automated + ONE manual step + verification plan | \"done\" |\n\nAfter response: verify if specified. Pass → continue. Fail → inform, wait. WAIT for user — do NOT hallucinate completion.\n\nSee ./.gemini/get-shit-done/references/checkpoints.md for details.\n</step>\n\n<step name=\"checkpoint_return_for_orchestrator\">\nWhen spawned via Task and hitting checkpoint: return structured state (cannot interact with user directly).\n\n**Required return:** 1) Completed Tasks table (hashes + files) 2) Current Task (what's blocking) 3) Checkpoint Details (user-facing content) 4) Awaiting (what's needed from user)\n\nOrchestrator parses → presents to user → spawns fresh continuation with your completed tasks state. You will NOT be resumed. In main context: use checkpoint_protocol above.\n</step>\n\n<step name=\"verification_failure_gate\">\nIf verification fails: STOP. Present: \"Verification failed for Task [X]: [name]. Expected: [criteria]. Actual: [result].\" Options: Retry | Skip (mark incomplete) | Stop (investigate). If skipped → SUMMARY \"Issues Encountered\".\n</step>\n\n<step name=\"record_completion_time\">\n```bash\nPLAN_END_TIME=$(date -u +\"%Y-%m-%dT%H:%M:%SZ\")\nPLAN_END_EPOCH=$(date +%s)\n\nDURATION_SEC=$(( PLAN_END_EPOCH - PLAN_START_EPOCH ))\nDURATION_MIN=$(( DURATION_SEC / 60 ))\n\nif [[ $DURATION_MIN -ge 60 ]]; then\n  HRS=$(( DURATION_MIN / 60 ))\n  MIN=$(( DURATION_MIN % 60 ))\n  DURATION=\"${HRS}h ${MIN}m\"\nelse\n  DURATION=\"${DURATION_MIN} min\"\nfi\n```\n</step>\n\n<step name=\"generate_user_setup\">\n```bash\ngrep -A 50 \"^user_setup:\" .planning/phases/XX-name/{phase}-{plan}-PLAN.md | head -50\n```\n\nIf user_setup exists: create `{phase}-USER-SETUP.md` using template `./.gemini/get-shit-done/templates/user-setup.md`. Per service: env vars table, account setup checklist, dashboard config, local dev notes, verification commands. Status \"Incomplete\". Set `USER_SETUP_CREATED=true`. If empty/missing: skip.\n</step>\n\n<step name=\"create_summary\">\nCreate `{phase}-{plan}-SUMMARY.md` at `.planning/phases/XX-name/`. Use `./.gemini/get-shit-done/templates/summary.md`.\n\n**Frontmatter:** phase, plan, subsystem, tags | requires/provides/affects | tech-stack.added/patterns | key-files.created/modified | key-decisions | duration ($DURATION), completed ($PLAN_END_TIME date).\n\nTitle: `# Phase [X] Plan [Y]: [Name] Summary`\n\nOne-liner SUBSTANTIVE: \"JWT auth with refresh rotation using jose library\" not \"Authentication implemented\"\n\nInclude: duration, start/end times, task count, file count.\n\nNext: more plans → \"Ready for {next-plan}\" | last → \"Phase complete, ready for transition\".\n</step>\n\n<step name=\"update_current_position\">\nUpdate STATE.md using gsd-tools:\n\n```bash\n# Advance plan counter (handles last-plan edge case)\nnode ./.gemini/get-shit-done/bin/gsd-tools.js state advance-plan\n\n# Recalculate progress bar from disk state\nnode ./.gemini/get-shit-done/bin/gsd-tools.js state update-progress\n\n# Record execution metrics\nnode ./.gemini/get-shit-done/bin/gsd-tools.js state record-metric \\\n  --phase \"${PHASE}\" --plan \"${PLAN}\" --duration \"${DURATION}\" \\\n  --tasks \"${TASK_COUNT}\" --files \"${FILE_COUNT}\"\n```\n</step>\n\n<step name=\"extract_decisions_and_issues\">\nFrom SUMMARY: Extract decisions and add to STATE.md:\n\n```bash\n# Add each decision from SUMMARY key-decisions\nnode ./.gemini/get-shit-done/bin/gsd-tools.js state add-decision \\\n  --phase \"${PHASE}\" --summary \"${DECISION_TEXT}\" --rationale \"${RATIONALE}\"\n\n# Add blockers if any found\nnode ./.gemini/get-shit-done/bin/gsd-tools.js state add-blocker \"Blocker description\"\n```\n</step>\n\n<step name=\"update_session_continuity\">\nUpdate session info using gsd-tools:\n\n```bash\nnode ./.gemini/get-shit-done/bin/gsd-tools.js state record-session \\\n  --stopped-at \"Completed ${PHASE}-${PLAN}-PLAN.md\" \\\n  --resume-file \"None\"\n```\n\nKeep STATE.md under 150 lines.\n</step>\n\n<step name=\"issues_review_gate\">\nIf SUMMARY \"Issues Encountered\" ≠ \"None\": yolo → log and continue. Interactive → present issues, wait for acknowledgment.\n</step>\n\n<step name=\"update_roadmap\">\nMore plans → update plan count, keep \"In progress\". Last plan → mark phase \"Complete\", add date.\n</step>\n\n<step name=\"git_commit_metadata\">\nTask code already committed per-task. Commit plan metadata:\n\n```bash\nnode ./.gemini/get-shit-done/bin/gsd-tools.js commit \"docs({phase}-{plan}): complete [plan-name] plan\" --files .planning/phases/XX-name/{phase}-{plan}-SUMMARY.md .planning/STATE.md .planning/ROADMAP.md\n```\n</step>\n\n<step name=\"update_codebase_map\">\nIf .planning/codebase/ doesn't exist: skip.\n\n```bash\nFIRST_TASK=$(git log --oneline --grep=\"feat({phase}-{plan}):\" --grep=\"fix({phase}-{plan}):\" --grep=\"test({phase}-{plan}):\" --reverse | head -1 | cut -d' ' -f1)\ngit diff --name-only ${FIRST_TASK}^..HEAD 2>/dev/null\n```\n\nUpdate only structural changes: new src/ dir → STRUCTURE.md | deps → STACK.md | file pattern → CONVENTIONS.md | API client → INTEGRATIONS.md | config → STACK.md | renamed → update paths. Skip code-only/bugfix/content changes.\n\n```bash\nnode ./.gemini/get-shit-done/bin/gsd-tools.js commit \"\" --files .planning/codebase/*.md --amend\n```\n</step>\n\n<step name=\"offer_next\">\nIf `USER_SETUP_CREATED=true`: display `⚠️ USER SETUP REQUIRED` with path + env/config tasks at TOP.\n\n```bash\nls -1 .planning/phases/[current-phase-dir]/*-PLAN.md 2>/dev/null | wc -l\nls -1 .planning/phases/[current-phase-dir]/*-SUMMARY.md 2>/dev/null | wc -l\n```\n\n| Condition | Route | Action |\n|-----------|-------|--------|\n| summaries < plans | **A: More plans** | Find next PLAN without SUMMARY. Yolo: auto-continue. Interactive: show next plan, suggest `/gsd:execute-phase {phase}` + `/gsd:verify-work`. STOP here. |\n| summaries = plans, current < highest phase | **B: Phase done** | Show completion, suggest `/gsd:plan-phase {Z+1}` + `/gsd:verify-work {Z}` + `/gsd:discuss-phase {Z+1}` |\n| summaries = plans, current = highest phase | **C: Milestone done** | Show banner, suggest `/gsd:complete-milestone` + `/gsd:verify-work` + `/gsd:add-phase` |\n\nAll routes: `/clear` first for fresh context.\n</step>\n\n</process>\n\n<success_criteria>\n\n- All tasks from PLAN.md completed\n- All verifications pass\n- USER-SETUP.md generated if user_setup in frontmatter\n- SUMMARY.md created with substantive content\n- STATE.md updated (position, decisions, issues, session)\n- ROADMAP.md updated\n- If codebase map exists: map updated with execution changes (or skipped if no significant changes)\n- If USER-SETUP.md created: prominently surfaced in completion output\n</success_criteria>\n"
