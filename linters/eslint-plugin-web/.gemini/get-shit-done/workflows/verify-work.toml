prompt = "<purpose>\nValidate built features through conversational testing with persistent state. Creates UAT.md that tracks test progress, survives /clear, and feeds gaps into /gsd:plan-phase --gaps.\n\nUser tests, Claude records. One test at a time. Plain text responses.\n</purpose>\n\n<philosophy>\n**Show expected, ask if reality matches.**\n\nClaude presents what SHOULD happen. User confirms or describes what's different.\n- \"yes\" / \"y\" / \"next\" / empty → pass\n- Anything else → logged as issue, severity inferred\n\nNo Pass/Fail buttons. No severity questions. Just: \"Here's what should happen. Does it?\"\n</philosophy>\n\n<template>\n@./.gemini/get-shit-done/templates/UAT.md\n</template>\n\n<process>\n\n<step name=\"initialize\" priority=\"first\">\nIf $ARGUMENTS contains a phase number, load context:\n\n```bash\nINIT=$(node ./.gemini/get-shit-done/bin/gsd-tools.js init verify-work \"${PHASE_ARG}\")\n```\n\nParse JSON for: `planner_model`, `checker_model`, `commit_docs`, `phase_found`, `phase_dir`, `phase_number`, `phase_name`, `has_verification`.\n</step>\n\n<step name=\"check_active_session\">\n**First: Check for active UAT sessions**\n\n```bash\nfind .planning/phases -name \"*-UAT.md\" -type f 2>/dev/null | head -5\n```\n\n**If active sessions exist AND no $ARGUMENTS provided:**\n\nRead each file's frontmatter (status, phase) and Current Test section.\n\nDisplay inline:\n\n```\n## Active UAT Sessions\n\n| # | Phase | Status | Current Test | Progress |\n|---|-------|--------|--------------|----------|\n| 1 | 04-comments | testing | 3. Reply to Comment | 2/6 |\n| 2 | 05-auth | testing | 1. Login Form | 0/4 |\n\nReply with a number to resume, or provide a phase number to start new.\n```\n\nWait for user response.\n\n- If user replies with number (1, 2) → Load that file, go to `resume_from_file`\n- If user replies with phase number → Treat as new session, go to `create_uat_file`\n\n**If active sessions exist AND $ARGUMENTS provided:**\n\nCheck if session exists for that phase. If yes, offer to resume or restart.\nIf no, continue to `create_uat_file`.\n\n**If no active sessions AND no $ARGUMENTS:**\n\n```\nNo active UAT sessions.\n\nProvide a phase number to start testing (e.g., /gsd:verify-work 4)\n```\n\n**If no active sessions AND $ARGUMENTS provided:**\n\nContinue to `create_uat_file`.\n</step>\n\n<step name=\"find_summaries\">\n**Find what to test:**\n\nUse `phase_dir` from init (or run init if not already done).\n\n```bash\nls \"$phase_dir\"/*-SUMMARY.md 2>/dev/null\n```\n\nRead each SUMMARY.md to extract testable deliverables.\n</step>\n\n<step name=\"extract_tests\">\n**Extract testable deliverables from SUMMARY.md:**\n\nParse for:\n1. **Accomplishments** - Features/functionality added\n2. **User-facing changes** - UI, workflows, interactions\n\nFocus on USER-OBSERVABLE outcomes, not implementation details.\n\nFor each deliverable, create a test:\n- name: Brief test name\n- expected: What the user should see/experience (specific, observable)\n\nExamples:\n- Accomplishment: \"Added comment threading with infinite nesting\"\n  → Test: \"Reply to a Comment\"\n  → Expected: \"Clicking Reply opens inline composer below comment. Submitting shows reply nested under parent with visual indentation.\"\n\nSkip internal/non-observable items (refactors, type changes, etc.).\n</step>\n\n<step name=\"create_uat_file\">\n**Create UAT file with all tests:**\n\n```bash\nmkdir -p \"$PHASE_DIR\"\n```\n\nBuild test list from extracted deliverables.\n\nCreate file:\n\n```markdown\n---\nstatus: testing\nphase: XX-name\nsource: [list of SUMMARY.md files]\nstarted: [ISO timestamp]\nupdated: [ISO timestamp]\n---\n\n## Current Test\n<!-- OVERWRITE each test - shows where we are -->\n\nnumber: 1\nname: [first test name]\nexpected: |\n  [what user should observe]\nawaiting: user response\n\n## Tests\n\n### 1. [Test Name]\nexpected: [observable behavior]\nresult: [pending]\n\n### 2. [Test Name]\nexpected: [observable behavior]\nresult: [pending]\n\n...\n\n## Summary\n\ntotal: [N]\npassed: 0\nissues: 0\npending: [N]\nskipped: 0\n\n## Gaps\n\n[none yet]\n```\n\nWrite to `.planning/phases/XX-name/{phase}-UAT.md`\n\nProceed to `present_test`.\n</step>\n\n<step name=\"present_test\">\n**Present current test to user:**\n\nRead Current Test section from UAT file.\n\nDisplay using checkpoint box format:\n\n```\n╔══════════════════════════════════════════════════════════════╗\n║  CHECKPOINT: Verification Required                           ║\n╚══════════════════════════════════════════════════════════════╝\n\n**Test {number}: {name}**\n\n{expected}\n\n──────────────────────────────────────────────────────────────\n→ Type \"pass\" or describe what's wrong\n──────────────────────────────────────────────────────────────\n```\n\nWait for user response (plain text, no AskUserQuestion).\n</step>\n\n<step name=\"process_response\">\n**Process user response and update file:**\n\n**If response indicates pass:**\n- Empty response, \"yes\", \"y\", \"ok\", \"pass\", \"next\", \"approved\", \"✓\"\n\nUpdate Tests section:\n```\n### {N}. {name}\nexpected: {expected}\nresult: pass\n```\n\n**If response indicates skip:**\n- \"skip\", \"can't test\", \"n/a\"\n\nUpdate Tests section:\n```\n### {N}. {name}\nexpected: {expected}\nresult: skipped\nreason: [user's reason if provided]\n```\n\n**If response is anything else:**\n- Treat as issue description\n\nInfer severity from description:\n- Contains: crash, error, exception, fails, broken, unusable → blocker\n- Contains: doesn't work, wrong, missing, can't → major\n- Contains: slow, weird, off, minor, small → minor\n- Contains: color, font, spacing, alignment, visual → cosmetic\n- Default if unclear: major\n\nUpdate Tests section:\n```\n### {N}. {name}\nexpected: {expected}\nresult: issue\nreported: \"{verbatim user response}\"\nseverity: {inferred}\n```\n\nAppend to Gaps section (structured YAML for plan-phase --gaps):\n```yaml\n- truth: \"{expected behavior from test}\"\n  status: failed\n  reason: \"User reported: {verbatim user response}\"\n  severity: {inferred}\n  test: {N}\n  artifacts: []  # Filled by diagnosis\n  missing: []    # Filled by diagnosis\n```\n\n**After any response:**\n\nUpdate Summary counts.\nUpdate frontmatter.updated timestamp.\n\nIf more tests remain → Update Current Test, go to `present_test`\nIf no more tests → Go to `complete_session`\n</step>\n\n<step name=\"resume_from_file\">\n**Resume testing from UAT file:**\n\nRead the full UAT file.\n\nFind first test with `result: [pending]`.\n\nAnnounce:\n```\nResuming: Phase {phase} UAT\nProgress: {passed + issues + skipped}/{total}\nIssues found so far: {issues count}\n\nContinuing from Test {N}...\n```\n\nUpdate Current Test section with the pending test.\nProceed to `present_test`.\n</step>\n\n<step name=\"complete_session\">\n**Complete testing and commit:**\n\nUpdate frontmatter:\n- status: complete\n- updated: [now]\n\nClear Current Test section:\n```\n## Current Test\n\n[testing complete]\n```\n\nCommit the UAT file:\n```bash\nnode ./.gemini/get-shit-done/bin/gsd-tools.js commit \"test({phase}): complete UAT - {passed} passed, {issues} issues\" --files \".planning/phases/XX-name/{phase}-UAT.md\"\n```\n\nPresent summary:\n```\n## UAT Complete: Phase {phase}\n\n| Result | Count |\n|--------|-------|\n| Passed | {N}   |\n| Issues | {N}   |\n| Skipped| {N}   |\n\n[If issues > 0:]\n### Issues Found\n\n[List from Issues section]\n```\n\n**If issues > 0:** Proceed to `diagnose_issues`\n\n**If issues == 0:**\n```\nAll tests passed. Ready to continue.\n\n- `/gsd:plan-phase {next}` — Plan next phase\n- `/gsd:execute-phase {next}` — Execute next phase\n```\n</step>\n\n<step name=\"diagnose_issues\">\n**Diagnose root causes before planning fixes:**\n\n```\n---\n\n{N} issues found. Diagnosing root causes...\n\nSpawning parallel debug agents to investigate each issue.\n```\n\n- Load diagnose-issues workflow\n- Follow @./.gemini/get-shit-done/workflows/diagnose-issues.md\n- Spawn parallel debug agents for each issue\n- Collect root causes\n- Update UAT.md with root causes\n- Proceed to `plan_gap_closure`\n\nDiagnosis runs automatically - no user prompt. Parallel agents investigate simultaneously, so overhead is minimal and fixes are more accurate.\n</step>\n\n<step name=\"plan_gap_closure\">\n**Auto-plan fixes from diagnosed gaps:**\n\nDisplay:\n```\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n GSD ► PLANNING FIXES\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n◆ Spawning planner for gap closure...\n```\n\nSpawn gsd-planner in --gaps mode:\n\n```\nTask(\n  prompt=\"\"\"\n<planning_context>\n\n**Phase:** {phase_number}\n**Mode:** gap_closure\n\n**UAT with diagnoses:**\n@.planning/phases/{phase_dir}/{phase}-UAT.md\n\n**Project State:**\n@.planning/STATE.md\n\n**Roadmap:**\n@.planning/ROADMAP.md\n\n</planning_context>\n\n<downstream_consumer>\nOutput consumed by /gsd:execute-phase\nPlans must be executable prompts.\n</downstream_consumer>\n\"\"\",\n  subagent_type=\"gsd-planner\",\n  model=\"{planner_model}\",\n  description=\"Plan gap fixes for Phase {phase}\"\n)\n```\n\nOn return:\n- **PLANNING COMPLETE:** Proceed to `verify_gap_plans`\n- **PLANNING INCONCLUSIVE:** Report and offer manual intervention\n</step>\n\n<step name=\"verify_gap_plans\">\n**Verify fix plans with checker:**\n\nDisplay:\n```\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n GSD ► VERIFYING FIX PLANS\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n◆ Spawning plan checker...\n```\n\nInitialize: `iteration_count = 1`\n\nSpawn gsd-plan-checker:\n\n```\nTask(\n  prompt=\"\"\"\n<verification_context>\n\n**Phase:** {phase_number}\n**Phase Goal:** Close diagnosed gaps from UAT\n\n**Plans to verify:**\n@.planning/phases/{phase_dir}/*-PLAN.md\n\n</verification_context>\n\n<expected_output>\nReturn one of:\n- ## VERIFICATION PASSED — all checks pass\n- ## ISSUES FOUND — structured issue list\n</expected_output>\n\"\"\",\n  subagent_type=\"gsd-plan-checker\",\n  model=\"{checker_model}\",\n  description=\"Verify Phase {phase} fix plans\"\n)\n```\n\nOn return:\n- **VERIFICATION PASSED:** Proceed to `present_ready`\n- **ISSUES FOUND:** Proceed to `revision_loop`\n</step>\n\n<step name=\"revision_loop\">\n**Iterate planner ↔ checker until plans pass (max 3):**\n\n**If iteration_count < 3:**\n\nDisplay: `Sending back to planner for revision... (iteration {N}/3)`\n\nSpawn gsd-planner with revision context:\n\n```\nTask(\n  prompt=\"\"\"\n<revision_context>\n\n**Phase:** {phase_number}\n**Mode:** revision\n\n**Existing plans:**\n@.planning/phases/{phase_dir}/*-PLAN.md\n\n**Checker issues:**\n{structured_issues_from_checker}\n\n</revision_context>\n\n<instructions>\nRead existing PLAN.md files. Make targeted updates to address checker issues.\nDo NOT replan from scratch unless issues are fundamental.\n</instructions>\n\"\"\",\n  subagent_type=\"gsd-planner\",\n  model=\"{planner_model}\",\n  description=\"Revise Phase {phase} plans\"\n)\n```\n\nAfter planner returns → spawn checker again (verify_gap_plans logic)\nIncrement iteration_count\n\n**If iteration_count >= 3:**\n\nDisplay: `Max iterations reached. {N} issues remain.`\n\nOffer options:\n1. Force proceed (execute despite issues)\n2. Provide guidance (user gives direction, retry)\n3. Abandon (exit, user runs /gsd:plan-phase manually)\n\nWait for user response.\n</step>\n\n<step name=\"present_ready\">\n**Present completion and next steps:**\n\n```\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n GSD ► FIXES READY ✓\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n**Phase {X}: {Name}** — {N} gap(s) diagnosed, {M} fix plan(s) created\n\n| Gap | Root Cause | Fix Plan |\n|-----|------------|----------|\n| {truth 1} | {root_cause} | {phase}-04 |\n| {truth 2} | {root_cause} | {phase}-04 |\n\nPlans verified and ready for execution.\n\n───────────────────────────────────────────────────────────────\n\n## ▶ Next Up\n\n**Execute fixes** — run fix plans\n\n`/clear` then `/gsd:execute-phase {phase} --gaps-only`\n\n───────────────────────────────────────────────────────────────\n```\n</step>\n\n</process>\n\n<update_rules>\n**Batched writes for efficiency:**\n\nKeep results in memory. Write to file only when:\n1. **Issue found** — Preserve the problem immediately\n2. **Session complete** — Final write before commit\n3. **Checkpoint** — Every 5 passed tests (safety net)\n\n| Section | Rule | When Written |\n|---------|------|--------------|\n| Frontmatter.status | OVERWRITE | Start, complete |\n| Frontmatter.updated | OVERWRITE | On any file write |\n| Current Test | OVERWRITE | On any file write |\n| Tests.{N}.result | OVERWRITE | On any file write |\n| Summary | OVERWRITE | On any file write |\n| Gaps | APPEND | When issue found |\n\nOn context reset: File shows last checkpoint. Resume from there.\n</update_rules>\n\n<severity_inference>\n**Infer severity from user's natural language:**\n\n| User says | Infer |\n|-----------|-------|\n| \"crashes\", \"error\", \"exception\", \"fails completely\" | blocker |\n| \"doesn't work\", \"nothing happens\", \"wrong behavior\" | major |\n| \"works but...\", \"slow\", \"weird\", \"minor issue\" | minor |\n| \"color\", \"spacing\", \"alignment\", \"looks off\" | cosmetic |\n\nDefault to **major** if unclear. User can correct if needed.\n\n**Never ask \"how severe is this?\"** - just infer and move on.\n</severity_inference>\n\n<success_criteria>\n- [ ] UAT file created with all tests from SUMMARY.md\n- [ ] Tests presented one at a time with expected behavior\n- [ ] User responses processed as pass/issue/skip\n- [ ] Severity inferred from description (never asked)\n- [ ] Batched writes: on issue, every 5 passes, or completion\n- [ ] Committed on completion\n- [ ] If issues: parallel debug agents diagnose root causes\n- [ ] If issues: gsd-planner creates fix plans (gap_closure mode)\n- [ ] If issues: gsd-plan-checker verifies fix plans\n- [ ] If issues: revision loop until plans pass (max 3 iterations)\n- [ ] Ready for `/gsd:execute-phase --gaps-only` when complete\n</success_criteria>\n"
