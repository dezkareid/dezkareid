prompt = "<overview>\nPlans execute autonomously. Checkpoints formalize interaction points where human verification or decisions are needed.\n\n**Core principle:** Claude automates everything with CLI/API. Checkpoints are for verification and decisions, not manual work.\n\n**Golden rules:**\n1. **If Claude can run it, Claude runs it** - Never ask user to execute CLI commands, start servers, or run builds\n2. **Claude sets up the verification environment** - Start dev servers, seed databases, configure env vars\n3. **User only does what requires human judgment** - Visual checks, UX evaluation, \"does this feel right?\"\n4. **Secrets come from user, automation comes from Claude** - Ask for API keys, then Claude uses them via CLI\n</overview>\n\n<checkpoint_types>\n\n<type name=\"human-verify\">\n## checkpoint:human-verify (Most Common - 90%)\n\n**When:** Claude completed automated work, human confirms it works correctly.\n\n**Use for:**\n- Visual UI checks (layout, styling, responsiveness)\n- Interactive flows (click through wizard, test user flows)\n- Functional verification (feature works as expected)\n- Audio/video playback quality\n- Animation smoothness\n- Accessibility testing\n\n**Structure:**\n```xml\n<task type=\"checkpoint:human-verify\" gate=\"blocking\">\n  <what-built>[What Claude automated and deployed/built]</what-built>\n  <how-to-verify>\n    [Exact steps to test - URLs, commands, expected behavior]\n  </how-to-verify>\n  <resume-signal>[How to continue - \"approved\", \"yes\", or describe issues]</resume-signal>\n</task>\n```\n\n**Example: UI Component (shows key pattern: Claude starts server BEFORE checkpoint)**\n```xml\n<task type=\"auto\">\n  <name>Build responsive dashboard layout</name>\n  <files>src/components/Dashboard.tsx, src/app/dashboard/page.tsx</files>\n  <action>Create dashboard with sidebar, header, and content area. Use Tailwind responsive classes for mobile.</action>\n  <verify>npm run build succeeds, no TypeScript errors</verify>\n  <done>Dashboard component builds without errors</done>\n</task>\n\n<task type=\"auto\">\n  <name>Start dev server for verification</name>\n  <action>Run `npm run dev` in background, wait for \"ready\" message, capture port</action>\n  <verify>curl http://localhost:3000 returns 200</verify>\n  <done>Dev server running at http://localhost:3000</done>\n</task>\n\n<task type=\"checkpoint:human-verify\" gate=\"blocking\">\n  <what-built>Responsive dashboard layout - dev server running at http://localhost:3000</what-built>\n  <how-to-verify>\n    Visit http://localhost:3000/dashboard and verify:\n    1. Desktop (>1024px): Sidebar left, content right, header top\n    2. Tablet (768px): Sidebar collapses to hamburger menu\n    3. Mobile (375px): Single column layout, bottom nav appears\n    4. No layout shift or horizontal scroll at any size\n  </how-to-verify>\n  <resume-signal>Type \"approved\" or describe layout issues</resume-signal>\n</task>\n```\n\n**Example: Xcode Build**\n```xml\n<task type=\"auto\">\n  <name>Build macOS app with Xcode</name>\n  <files>App.xcodeproj, Sources/</files>\n  <action>Run `xcodebuild -project App.xcodeproj -scheme App build`. Check for compilation errors in output.</action>\n  <verify>Build output contains \"BUILD SUCCEEDED\", no errors</verify>\n  <done>App builds successfully</done>\n</task>\n\n<task type=\"checkpoint:human-verify\" gate=\"blocking\">\n  <what-built>Built macOS app at DerivedData/Build/Products/Debug/App.app</what-built>\n  <how-to-verify>\n    Open App.app and test:\n    - App launches without crashes\n    - Menu bar icon appears\n    - Preferences window opens correctly\n    - No visual glitches or layout issues\n  </how-to-verify>\n  <resume-signal>Type \"approved\" or describe issues</resume-signal>\n</task>\n```\n</type>\n\n<type name=\"decision\">\n## checkpoint:decision (9%)\n\n**When:** Human must make choice that affects implementation direction.\n\n**Use for:**\n- Technology selection (which auth provider, which database)\n- Architecture decisions (monorepo vs separate repos)\n- Design choices (color scheme, layout approach)\n- Feature prioritization (which variant to build)\n- Data model decisions (schema structure)\n\n**Structure:**\n```xml\n<task type=\"checkpoint:decision\" gate=\"blocking\">\n  <decision>[What's being decided]</decision>\n  <context>[Why this decision matters]</context>\n  <options>\n    <option id=\"option-a\">\n      <name>[Option name]</name>\n      <pros>[Benefits]</pros>\n      <cons>[Tradeoffs]</cons>\n    </option>\n    <option id=\"option-b\">\n      <name>[Option name]</name>\n      <pros>[Benefits]</pros>\n      <cons>[Tradeoffs]</cons>\n    </option>\n  </options>\n  <resume-signal>[How to indicate choice]</resume-signal>\n</task>\n```\n\n**Example: Auth Provider Selection**\n```xml\n<task type=\"checkpoint:decision\" gate=\"blocking\">\n  <decision>Select authentication provider</decision>\n  <context>\n    Need user authentication for the app. Three solid options with different tradeoffs.\n  </context>\n  <options>\n    <option id=\"supabase\">\n      <name>Supabase Auth</name>\n      <pros>Built-in with Supabase DB we're using, generous free tier, row-level security integration</pros>\n      <cons>Less customizable UI, tied to Supabase ecosystem</cons>\n    </option>\n    <option id=\"clerk\">\n      <name>Clerk</name>\n      <pros>Beautiful pre-built UI, best developer experience, excellent docs</pros>\n      <cons>Paid after 10k MAU, vendor lock-in</cons>\n    </option>\n    <option id=\"nextauth\">\n      <name>NextAuth.js</name>\n      <pros>Free, self-hosted, maximum control, widely adopted</pros>\n      <cons>More setup work, you manage security updates, UI is DIY</cons>\n    </option>\n  </options>\n  <resume-signal>Select: supabase, clerk, or nextauth</resume-signal>\n</task>\n```\n\n**Example: Database Selection**\n```xml\n<task type=\"checkpoint:decision\" gate=\"blocking\">\n  <decision>Select database for user data</decision>\n  <context>\n    App needs persistent storage for users, sessions, and user-generated content.\n    Expected scale: 10k users, 1M records first year.\n  </context>\n  <options>\n    <option id=\"supabase\">\n      <name>Supabase (Postgres)</name>\n      <pros>Full SQL, generous free tier, built-in auth, real-time subscriptions</pros>\n      <cons>Vendor lock-in for real-time features, less flexible than raw Postgres</cons>\n    </option>\n    <option id=\"planetscale\">\n      <name>PlanetScale (MySQL)</name>\n      <pros>Serverless scaling, branching workflow, excellent DX</pros>\n      <cons>MySQL not Postgres, no foreign keys in free tier</cons>\n    </option>\n    <option id=\"convex\">\n      <name>Convex</name>\n      <pros>Real-time by default, TypeScript-native, automatic caching</pros>\n      <cons>Newer platform, different mental model, less SQL flexibility</cons>\n    </option>\n  </options>\n  <resume-signal>Select: supabase, planetscale, or convex</resume-signal>\n</task>\n```\n</type>\n\n<type name=\"human-action\">\n## checkpoint:human-action (1% - Rare)\n\n**When:** Action has NO CLI/API and requires human-only interaction, OR Claude hit an authentication gate during automation.\n\n**Use ONLY for:**\n- **Authentication gates** - Claude tried CLI/API but needs credentials (this is NOT a failure)\n- Email verification links (clicking email)\n- SMS 2FA codes (phone verification)\n- Manual account approvals (platform requires human review)\n- Credit card 3D Secure flows (web-based payment authorization)\n- OAuth app approvals (web-based approval)\n\n**Do NOT use for pre-planned manual work:**\n- Deploying (use CLI - auth gate if needed)\n- Creating webhooks/databases (use API/CLI - auth gate if needed)\n- Running builds/tests (use Bash tool)\n- Creating files (use Write tool)\n\n**Structure:**\n```xml\n<task type=\"checkpoint:human-action\" gate=\"blocking\">\n  <action>[What human must do - Claude already did everything automatable]</action>\n  <instructions>\n    [What Claude already automated]\n    [The ONE thing requiring human action]\n  </instructions>\n  <verification>[What Claude can check afterward]</verification>\n  <resume-signal>[How to continue]</resume-signal>\n</task>\n```\n\n**Example: Email Verification**\n```xml\n<task type=\"auto\">\n  <name>Create SendGrid account via API</name>\n  <action>Use SendGrid API to create subuser account with provided email. Request verification email.</action>\n  <verify>API returns 201, account created</verify>\n  <done>Account created, verification email sent</done>\n</task>\n\n<task type=\"checkpoint:human-action\" gate=\"blocking\">\n  <action>Complete email verification for SendGrid account</action>\n  <instructions>\n    I created the account and requested verification email.\n    Check your inbox for SendGrid verification link and click it.\n  </instructions>\n  <verification>SendGrid API key works: curl test succeeds</verification>\n  <resume-signal>Type \"done\" when email verified</resume-signal>\n</task>\n```\n\n**Example: Authentication Gate (Dynamic Checkpoint)**\n```xml\n<task type=\"auto\">\n  <name>Deploy to Vercel</name>\n  <files>.vercel/, vercel.json</files>\n  <action>Run `vercel --yes` to deploy</action>\n  <verify>vercel ls shows deployment, curl returns 200</verify>\n</task>\n\n<!-- If vercel returns \"Error: Not authenticated\", Claude creates checkpoint on the fly -->\n\n<task type=\"checkpoint:human-action\" gate=\"blocking\">\n  <action>Authenticate Vercel CLI so I can continue deployment</action>\n  <instructions>\n    I tried to deploy but got authentication error.\n    Run: vercel login\n    This will open your browser - complete the authentication flow.\n  </instructions>\n  <verification>vercel whoami returns your account email</verification>\n  <resume-signal>Type \"done\" when authenticated</resume-signal>\n</task>\n\n<!-- After authentication, Claude retries the deployment -->\n\n<task type=\"auto\">\n  <name>Retry Vercel deployment</name>\n  <action>Run `vercel --yes` (now authenticated)</action>\n  <verify>vercel ls shows deployment, curl returns 200</verify>\n</task>\n```\n\n**Key distinction:** Auth gates are created dynamically when Claude encounters auth errors. NOT pre-planned — Claude automates first, asks for credentials only when blocked.\n</type>\n</checkpoint_types>\n\n<execution_protocol>\n\nWhen Claude encounters `type=\"checkpoint:*\"`:\n\n1. **Stop immediately** - do not proceed to next task\n2. **Display checkpoint clearly** using the format below\n3. **Wait for user response** - do not hallucinate completion\n4. **Verify if possible** - check files, run tests, whatever is specified\n5. **Resume execution** - continue to next task only after confirmation\n\n**For checkpoint:human-verify:**\n```\n╔═══════════════════════════════════════════════════════╗\n║  CHECKPOINT: Verification Required                    ║\n╚═══════════════════════════════════════════════════════╝\n\nProgress: 5/8 tasks complete\nTask: Responsive dashboard layout\n\nBuilt: Responsive dashboard at /dashboard\n\nHow to verify:\n  1. Visit: http://localhost:3000/dashboard\n  2. Desktop (>1024px): Sidebar visible, content fills remaining space\n  3. Tablet (768px): Sidebar collapses to icons\n  4. Mobile (375px): Sidebar hidden, hamburger menu appears\n\n────────────────────────────────────────────────────────\n→ YOUR ACTION: Type \"approved\" or describe issues\n────────────────────────────────────────────────────────\n```\n\n**For checkpoint:decision:**\n```\n╔═══════════════════════════════════════════════════════╗\n║  CHECKPOINT: Decision Required                        ║\n╚═══════════════════════════════════════════════════════╝\n\nProgress: 2/6 tasks complete\nTask: Select authentication provider\n\nDecision: Which auth provider should we use?\n\nContext: Need user authentication. Three options with different tradeoffs.\n\nOptions:\n  1. supabase - Built-in with our DB, free tier\n     Pros: Row-level security integration, generous free tier\n     Cons: Less customizable UI, ecosystem lock-in\n\n  2. clerk - Best DX, paid after 10k users\n     Pros: Beautiful pre-built UI, excellent documentation\n     Cons: Vendor lock-in, pricing at scale\n\n  3. nextauth - Self-hosted, maximum control\n     Pros: Free, no vendor lock-in, widely adopted\n     Cons: More setup work, DIY security updates\n\n────────────────────────────────────────────────────────\n→ YOUR ACTION: Select supabase, clerk, or nextauth\n────────────────────────────────────────────────────────\n```\n\n**For checkpoint:human-action:**\n```\n╔═══════════════════════════════════════════════════════╗\n║  CHECKPOINT: Action Required                          ║\n╚═══════════════════════════════════════════════════════╝\n\nProgress: 3/8 tasks complete\nTask: Deploy to Vercel\n\nAttempted: vercel --yes\nError: Not authenticated. Please run 'vercel login'\n\nWhat you need to do:\n  1. Run: vercel login\n  2. Complete browser authentication when it opens\n  3. Return here when done\n\nI'll verify: vercel whoami returns your account\n\n────────────────────────────────────────────────────────\n→ YOUR ACTION: Type \"done\" when authenticated\n────────────────────────────────────────────────────────\n```\n</execution_protocol>\n\n<authentication_gates>\n\n**Auth gate = Claude tried CLI/API, got auth error.** Not a failure — a gate requiring human input to unblock.\n\n**Pattern:** Claude tries automation → auth error → creates checkpoint:human-action → user authenticates → Claude retries → continues\n\n**Gate protocol:**\n1. Recognize it's not a failure - missing auth is expected\n2. Stop current task - don't retry repeatedly\n3. Create checkpoint:human-action dynamically\n4. Provide exact authentication steps\n5. Verify authentication works\n6. Retry the original task\n7. Continue normally\n\n**Key distinction:**\n- Pre-planned checkpoint: \"I need you to do X\" (wrong - Claude should automate)\n- Auth gate: \"I tried to automate X but need credentials\" (correct - unblocks automation)\n\n</authentication_gates>\n\n<automation_reference>\n\n**The rule:** If it has CLI/API, Claude does it. Never ask human to perform automatable work.\n\n## Service CLI Reference\n\n| Service | CLI/API | Key Commands | Auth Gate |\n|---------|---------|--------------|-----------|\n| Vercel | `vercel` | `--yes`, `env add`, `--prod`, `ls` | `vercel login` |\n| Railway | `railway` | `init`, `up`, `variables set` | `railway login` |\n| Fly | `fly` | `launch`, `deploy`, `secrets set` | `fly auth login` |\n| Stripe | `stripe` + API | `listen`, `trigger`, API calls | API key in .env |\n| Supabase | `supabase` | `init`, `link`, `db push`, `gen types` | `supabase login` |\n| Upstash | `upstash` | `redis create`, `redis get` | `upstash auth login` |\n| PlanetScale | `pscale` | `database create`, `branch create` | `pscale auth login` |\n| GitHub | `gh` | `repo create`, `pr create`, `secret set` | `gh auth login` |\n| Node | `npm`/`pnpm` | `install`, `run build`, `test`, `run dev` | N/A |\n| Xcode | `xcodebuild` | `-project`, `-scheme`, `build`, `test` | N/A |\n| Convex | `npx convex` | `dev`, `deploy`, `env set`, `env get` | `npx convex login` |\n\n## Environment Variable Automation\n\n**Env files:** Use Write/Edit tools. Never ask human to create .env manually.\n\n**Dashboard env vars via CLI:**\n\n| Platform | CLI Command | Example |\n|----------|-------------|---------|\n| Convex | `npx convex env set` | `npx convex env set OPENAI_API_KEY sk-...` |\n| Vercel | `vercel env add` | `vercel env add STRIPE_KEY production` |\n| Railway | `railway variables set` | `railway variables set API_KEY=value` |\n| Fly | `fly secrets set` | `fly secrets set DATABASE_URL=...` |\n| Supabase | `supabase secrets set` | `supabase secrets set MY_SECRET=value` |\n\n**Secret collection pattern:**\n```xml\n<!-- WRONG: Asking user to add env vars in dashboard -->\n<task type=\"checkpoint:human-action\">\n  <action>Add OPENAI_API_KEY to Convex dashboard</action>\n  <instructions>Go to dashboard.convex.dev → Settings → Environment Variables → Add</instructions>\n</task>\n\n<!-- RIGHT: Claude asks for value, then adds via CLI -->\n<task type=\"checkpoint:human-action\">\n  <action>Provide your OpenAI API key</action>\n  <instructions>\n    I need your OpenAI API key for Convex backend.\n    Get it from: https://platform.openai.com/api-keys\n    Paste the key (starts with sk-)\n  </instructions>\n  <verification>I'll add it via `npx convex env set` and verify</verification>\n  <resume-signal>Paste your API key</resume-signal>\n</task>\n\n<task type=\"auto\">\n  <name>Configure OpenAI key in Convex</name>\n  <action>Run `npx convex env set OPENAI_API_KEY {user-provided-key}`</action>\n  <verify>`npx convex env get OPENAI_API_KEY` returns the key (masked)</verify>\n</task>\n```\n\n## Dev Server Automation\n\n| Framework | Start Command | Ready Signal | Default URL |\n|-----------|---------------|--------------|-------------|\n| Next.js | `npm run dev` | \"Ready in\" or \"started server\" | http://localhost:3000 |\n| Vite | `npm run dev` | \"ready in\" | http://localhost:5173 |\n| Convex | `npx convex dev` | \"Convex functions ready\" | N/A (backend only) |\n| Express | `npm start` | \"listening on port\" | http://localhost:3000 |\n| Django | `python manage.py runserver` | \"Starting development server\" | http://localhost:8000 |\n\n**Server lifecycle:**\n```bash\n# Run in background, capture PID\nnpm run dev &\nDEV_SERVER_PID=$!\n\n# Wait for ready (max 30s)\ntimeout 30 bash -c 'until curl -s localhost:3000 > /dev/null 2>&1; do sleep 1; done'\n```\n\n**Port conflicts:** Kill stale process (`lsof -ti:3000 | xargs kill`) or use alternate port (`--port 3001`).\n\n**Server stays running** through checkpoints. Only kill when plan complete, switching to production, or port needed for different service.\n\n## CLI Installation Handling\n\n| CLI | Auto-install? | Command |\n|-----|---------------|---------|\n| npm/pnpm/yarn | No - ask user | User chooses package manager |\n| vercel | Yes | `npm i -g vercel` |\n| gh (GitHub) | Yes | `brew install gh` (macOS) or `apt install gh` (Linux) |\n| stripe | Yes | `npm i -g stripe` |\n| supabase | Yes | `npm i -g supabase` |\n| convex | No - use npx | `npx convex` (no install needed) |\n| fly | Yes | `brew install flyctl` or curl installer |\n| railway | Yes | `npm i -g @railway/cli` |\n\n**Protocol:** Try command → \"command not found\" → auto-installable? → yes: install silently, retry → no: checkpoint asking user to install.\n\n## Pre-Checkpoint Automation Failures\n\n| Failure | Response |\n|---------|----------|\n| Server won't start | Check error, fix issue, retry (don't proceed to checkpoint) |\n| Port in use | Kill stale process or use alternate port |\n| Missing dependency | Run `npm install`, retry |\n| Build error | Fix the error first (bug, not checkpoint issue) |\n| Auth error | Create auth gate checkpoint |\n| Network timeout | Retry with backoff, then checkpoint if persistent |\n\n**Never present a checkpoint with broken verification environment.** If `curl localhost:3000` fails, don't ask user to \"visit localhost:3000\".\n\n```xml\n<!-- WRONG: Checkpoint with broken environment -->\n<task type=\"checkpoint:human-verify\">\n  <what-built>Dashboard (server failed to start)</what-built>\n  <how-to-verify>Visit http://localhost:3000...</how-to-verify>\n</task>\n\n<!-- RIGHT: Fix first, then checkpoint -->\n<task type=\"auto\">\n  <name>Fix server startup issue</name>\n  <action>Investigate error, fix root cause, restart server</action>\n  <verify>curl http://localhost:3000 returns 200</verify>\n</task>\n\n<task type=\"checkpoint:human-verify\">\n  <what-built>Dashboard - server running at http://localhost:3000</what-built>\n  <how-to-verify>Visit http://localhost:3000/dashboard...</how-to-verify>\n</task>\n```\n\n## Automatable Quick Reference\n\n| Action | Automatable? | Claude does it? |\n|--------|--------------|-----------------|\n| Deploy to Vercel | Yes (`vercel`) | YES |\n| Create Stripe webhook | Yes (API) | YES |\n| Write .env file | Yes (Write tool) | YES |\n| Create Upstash DB | Yes (`upstash`) | YES |\n| Run tests | Yes (`npm test`) | YES |\n| Start dev server | Yes (`npm run dev`) | YES |\n| Add env vars to Convex | Yes (`npx convex env set`) | YES |\n| Add env vars to Vercel | Yes (`vercel env add`) | YES |\n| Seed database | Yes (CLI/API) | YES |\n| Click email verification link | No | NO |\n| Enter credit card with 3DS | No | NO |\n| Complete OAuth in browser | No | NO |\n| Visually verify UI looks correct | No | NO |\n| Test interactive user flows | No | NO |\n\n</automation_reference>\n\n<writing_guidelines>\n\n**DO:**\n- Automate everything with CLI/API before checkpoint\n- Be specific: \"Visit https://myapp.vercel.app\" not \"check deployment\"\n- Number verification steps\n- State expected outcomes: \"You should see X\"\n- Provide context: why this checkpoint exists\n\n**DON'T:**\n- Ask human to do work Claude can automate ❌\n- Assume knowledge: \"Configure the usual settings\" ❌\n- Skip steps: \"Set up database\" (too vague) ❌\n- Mix multiple verifications in one checkpoint ❌\n\n**Placement:**\n- **After automation completes** - not before Claude does the work\n- **After UI buildout** - before declaring phase complete\n- **Before dependent work** - decisions before implementation\n- **At integration points** - after configuring external services\n\n**Bad placement:** Before automation ❌ | Too frequent ❌ | Too late (dependent tasks already needed the result) ❌\n</writing_guidelines>\n\n<examples>\n\n### Example 1: Database Setup (No Checkpoint Needed)\n\n```xml\n<task type=\"auto\">\n  <name>Create Upstash Redis database</name>\n  <files>.env</files>\n  <action>\n    1. Run `upstash redis create myapp-cache --region us-east-1`\n    2. Capture connection URL from output\n    3. Write to .env: UPSTASH_REDIS_URL={url}\n    4. Verify connection with test command\n  </action>\n  <verify>\n    - upstash redis list shows database\n    - .env contains UPSTASH_REDIS_URL\n    - Test connection succeeds\n  </verify>\n  <done>Redis database created and configured</done>\n</task>\n\n<!-- NO CHECKPOINT NEEDED - Claude automated everything and verified programmatically -->\n```\n\n### Example 2: Full Auth Flow (Single checkpoint at end)\n\n```xml\n<task type=\"auto\">\n  <name>Create user schema</name>\n  <files>src/db/schema.ts</files>\n  <action>Define User, Session, Account tables with Drizzle ORM</action>\n  <verify>npm run db:generate succeeds</verify>\n</task>\n\n<task type=\"auto\">\n  <name>Create auth API routes</name>\n  <files>src/app/api/auth/[...nextauth]/route.ts</files>\n  <action>Set up NextAuth with GitHub provider, JWT strategy</action>\n  <verify>TypeScript compiles, no errors</verify>\n</task>\n\n<task type=\"auto\">\n  <name>Create login UI</name>\n  <files>src/app/login/page.tsx, src/components/LoginButton.tsx</files>\n  <action>Create login page with GitHub OAuth button</action>\n  <verify>npm run build succeeds</verify>\n</task>\n\n<task type=\"auto\">\n  <name>Start dev server for auth testing</name>\n  <action>Run `npm run dev` in background, wait for ready signal</action>\n  <verify>curl http://localhost:3000 returns 200</verify>\n  <done>Dev server running at http://localhost:3000</done>\n</task>\n\n<!-- ONE checkpoint at end verifies the complete flow -->\n<task type=\"checkpoint:human-verify\" gate=\"blocking\">\n  <what-built>Complete authentication flow - dev server running at http://localhost:3000</what-built>\n  <how-to-verify>\n    1. Visit: http://localhost:3000/login\n    2. Click \"Sign in with GitHub\"\n    3. Complete GitHub OAuth flow\n    4. Verify: Redirected to /dashboard, user name displayed\n    5. Refresh page: Session persists\n    6. Click logout: Session cleared\n  </how-to-verify>\n  <resume-signal>Type \"approved\" or describe issues</resume-signal>\n</task>\n```\n</examples>\n\n<anti_patterns>\n\n### ❌ BAD: Asking user to start dev server\n\n```xml\n<task type=\"checkpoint:human-verify\" gate=\"blocking\">\n  <what-built>Dashboard component</what-built>\n  <how-to-verify>\n    1. Run: npm run dev\n    2. Visit: http://localhost:3000/dashboard\n    3. Check layout is correct\n  </how-to-verify>\n</task>\n```\n\n**Why bad:** Claude can run `npm run dev`. User should only visit URLs, not execute commands.\n\n### ✅ GOOD: Claude starts server, user visits\n\n```xml\n<task type=\"auto\">\n  <name>Start dev server</name>\n  <action>Run `npm run dev` in background</action>\n  <verify>curl localhost:3000 returns 200</verify>\n</task>\n\n<task type=\"checkpoint:human-verify\" gate=\"blocking\">\n  <what-built>Dashboard at http://localhost:3000/dashboard (server running)</what-built>\n  <how-to-verify>\n    Visit http://localhost:3000/dashboard and verify:\n    1. Layout matches design\n    2. No console errors\n  </how-to-verify>\n</task>\n```\n\n### ❌ BAD: Asking human to deploy / ✅ GOOD: Claude automates\n\n```xml\n<!-- BAD: Asking user to deploy via dashboard -->\n<task type=\"checkpoint:human-action\" gate=\"blocking\">\n  <action>Deploy to Vercel</action>\n  <instructions>Visit vercel.com/new → Import repo → Click Deploy → Copy URL</instructions>\n</task>\n\n<!-- GOOD: Claude deploys, user verifies -->\n<task type=\"auto\">\n  <name>Deploy to Vercel</name>\n  <action>Run `vercel --yes`. Capture URL.</action>\n  <verify>vercel ls shows deployment, curl returns 200</verify>\n</task>\n\n<task type=\"checkpoint:human-verify\">\n  <what-built>Deployed to {url}</what-built>\n  <how-to-verify>Visit {url}, check homepage loads</how-to-verify>\n  <resume-signal>Type \"approved\"</resume-signal>\n</task>\n```\n\n### ❌ BAD: Too many checkpoints / ✅ GOOD: Single checkpoint\n\n```xml\n<!-- BAD: Checkpoint after every task -->\n<task type=\"auto\">Create schema</task>\n<task type=\"checkpoint:human-verify\">Check schema</task>\n<task type=\"auto\">Create API route</task>\n<task type=\"checkpoint:human-verify\">Check API</task>\n<task type=\"auto\">Create UI form</task>\n<task type=\"checkpoint:human-verify\">Check form</task>\n\n<!-- GOOD: One checkpoint at end -->\n<task type=\"auto\">Create schema</task>\n<task type=\"auto\">Create API route</task>\n<task type=\"auto\">Create UI form</task>\n\n<task type=\"checkpoint:human-verify\">\n  <what-built>Complete auth flow (schema + API + UI)</what-built>\n  <how-to-verify>Test full flow: register, login, access protected page</how-to-verify>\n  <resume-signal>Type \"approved\"</resume-signal>\n</task>\n```\n\n### ❌ BAD: Vague verification / ✅ GOOD: Specific steps\n\n```xml\n<!-- BAD -->\n<task type=\"checkpoint:human-verify\">\n  <what-built>Dashboard</what-built>\n  <how-to-verify>Check it works</how-to-verify>\n</task>\n\n<!-- GOOD -->\n<task type=\"checkpoint:human-verify\">\n  <what-built>Responsive dashboard - server running at http://localhost:3000</what-built>\n  <how-to-verify>\n    Visit http://localhost:3000/dashboard and verify:\n    1. Desktop (>1024px): Sidebar visible, content area fills remaining space\n    2. Tablet (768px): Sidebar collapses to icons\n    3. Mobile (375px): Sidebar hidden, hamburger menu in header\n    4. No horizontal scroll at any size\n  </how-to-verify>\n  <resume-signal>Type \"approved\" or describe layout issues</resume-signal>\n</task>\n```\n\n### ❌ BAD: Asking user to run CLI commands\n\n```xml\n<task type=\"checkpoint:human-action\">\n  <action>Run database migrations</action>\n  <instructions>Run: npx prisma migrate deploy && npx prisma db seed</instructions>\n</task>\n```\n\n**Why bad:** Claude can run these commands. User should never execute CLI commands.\n\n### ❌ BAD: Asking user to copy values between services\n\n```xml\n<task type=\"checkpoint:human-action\">\n  <action>Configure webhook URL in Stripe</action>\n  <instructions>Copy deployment URL → Stripe Dashboard → Webhooks → Add endpoint → Copy secret → Add to .env</instructions>\n</task>\n```\n\n**Why bad:** Stripe has an API. Claude should create the webhook via API and write to .env directly.\n\n</anti_patterns>\n\n<summary>\n\nCheckpoints formalize human-in-the-loop points for verification and decisions, not manual work.\n\n**The golden rule:** If Claude CAN automate it, Claude MUST automate it.\n\n**Checkpoint priority:**\n1. **checkpoint:human-verify** (90%) - Claude automated everything, human confirms visual/functional correctness\n2. **checkpoint:decision** (9%) - Human makes architectural/technology choices\n3. **checkpoint:human-action** (1%) - Truly unavoidable manual steps with no API/CLI\n\n**When NOT to use checkpoints:**\n- Things Claude can verify programmatically (tests, builds)\n- File operations (Claude can read files)\n- Code correctness (tests and static analysis)\n- Anything automatable via CLI/API\n</summary>\n"
