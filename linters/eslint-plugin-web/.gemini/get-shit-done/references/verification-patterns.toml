prompt = "# Verification Patterns\n\nHow to verify different types of artifacts are real implementations, not stubs or placeholders.\n\n<core_principle>\n**Existence ≠ Implementation**\n\nA file existing does not mean the feature works. Verification must check:\n1. **Exists** - File is present at expected path\n2. **Substantive** - Content is real implementation, not placeholder\n3. **Wired** - Connected to the rest of the system\n4. **Functional** - Actually works when invoked\n\nLevels 1-3 can be checked programmatically. Level 4 often requires human verification.\n</core_principle>\n\n<stub_detection>\n\n## Universal Stub Patterns\n\nThese patterns indicate placeholder code regardless of file type:\n\n**Comment-based stubs:**\n```bash\n# Grep patterns for stub comments\ngrep -E \"(TODO|FIXME|XXX|HACK|PLACEHOLDER)\" \"$file\"\ngrep -E \"implement|add later|coming soon|will be\" \"$file\" -i\ngrep -E \"// \\.\\.\\.|/\\* \\.\\.\\. \\*/|# \\.\\.\\.\" \"$file\"\n```\n\n**Placeholder text in output:**\n```bash\n# UI placeholder patterns\ngrep -E \"placeholder|lorem ipsum|coming soon|under construction\" \"$file\" -i\ngrep -E \"sample|example|test data|dummy\" \"$file\" -i\ngrep -E \"\\[.*\\]|<.*>|\\{.*\\}\" \"$file\"  # Template brackets left in\n```\n\n**Empty or trivial implementations:**\n```bash\n# Functions that do nothing\ngrep -E \"return null|return undefined|return \\{\\}|return \\[\\]\" \"$file\"\ngrep -E \"pass$|\\.\\.\\.|\\bnothing\\b\" \"$file\"\ngrep -E \"console\\.(log|warn|error).*only\" \"$file\"  # Log-only functions\n```\n\n**Hardcoded values where dynamic expected:**\n```bash\n# Hardcoded IDs, counts, or content\ngrep -E \"id.*=.*['\\\"].*['\\\"]\" \"$file\"  # Hardcoded string IDs\ngrep -E \"count.*=.*\\d+|length.*=.*\\d+\" \"$file\"  # Hardcoded counts\ngrep -E \"\\\\\\$\\d+\\.\\d{2}|\\d+ items\" \"$file\"  # Hardcoded display values\n```\n\n</stub_detection>\n\n<react_components>\n\n## React/Next.js Components\n\n**Existence check:**\n```bash\n# File exists and exports component\n[ -f \"$component_path\" ] && grep -E \"export (default |)function|export const.*=.*\\(\" \"$component_path\"\n```\n\n**Substantive check:**\n```bash\n# Returns actual JSX, not placeholder\ngrep -E \"return.*<\" \"$component_path\" | grep -v \"return.*null\" | grep -v \"placeholder\" -i\n\n# Has meaningful content (not just wrapper div)\ngrep -E \"<[A-Z][a-zA-Z]+|className=|onClick=|onChange=\" \"$component_path\"\n\n# Uses props or state (not static)\ngrep -E \"props\\.|useState|useEffect|useContext|\\{.*\\}\" \"$component_path\"\n```\n\n**Stub patterns specific to React:**\n```javascript\n// RED FLAGS - These are stubs:\nreturn <div>Component</div>\nreturn <div>Placeholder</div>\nreturn <div>{/* TODO */}</div>\nreturn <p>Coming soon</p>\nreturn null\nreturn <></>\n\n// Also stubs - empty handlers:\nonClick={() => {}}\nonChange={() => console.log('clicked')}\nonSubmit={(e) => e.preventDefault()}  // Only prevents default, does nothing\n```\n\n**Wiring check:**\n```bash\n# Component imports what it needs\ngrep -E \"^import.*from\" \"$component_path\"\n\n# Props are actually used (not just received)\n# Look for destructuring or props.X usage\ngrep -E \"\\{ .* \\}.*props|\\bprops\\.[a-zA-Z]+\" \"$component_path\"\n\n# API calls exist (for data-fetching components)\ngrep -E \"fetch\\(|axios\\.|useSWR|useQuery|getServerSideProps|getStaticProps\" \"$component_path\"\n```\n\n**Functional verification (human required):**\n- Does the component render visible content?\n- Do interactive elements respond to clicks?\n- Does data load and display?\n- Do error states show appropriately?\n\n</react_components>\n\n<api_routes>\n\n## API Routes (Next.js App Router / Express / etc.)\n\n**Existence check:**\n```bash\n# Route file exists\n[ -f \"$route_path\" ]\n\n# Exports HTTP method handlers (Next.js App Router)\ngrep -E \"export (async )?(function|const) (GET|POST|PUT|PATCH|DELETE)\" \"$route_path\"\n\n# Or Express-style handlers\ngrep -E \"\\.(get|post|put|patch|delete)\\(\" \"$route_path\"\n```\n\n**Substantive check:**\n```bash\n# Has actual logic, not just return statement\nwc -l \"$route_path\"  # More than 10-15 lines suggests real implementation\n\n# Interacts with data source\ngrep -E \"prisma\\.|db\\.|mongoose\\.|sql|query|find|create|update|delete\" \"$route_path\" -i\n\n# Has error handling\ngrep -E \"try|catch|throw|error|Error\" \"$route_path\"\n\n# Returns meaningful response\ngrep -E \"Response\\.json|res\\.json|res\\.send|return.*\\{\" \"$route_path\" | grep -v \"message.*not implemented\" -i\n```\n\n**Stub patterns specific to API routes:**\n```typescript\n// RED FLAGS - These are stubs:\nexport async function POST() {\n  return Response.json({ message: \"Not implemented\" })\n}\n\nexport async function GET() {\n  return Response.json([])  // Empty array with no DB query\n}\n\nexport async function PUT() {\n  return new Response()  // Empty response\n}\n\n// Console log only:\nexport async function POST(req) {\n  console.log(await req.json())\n  return Response.json({ ok: true })\n}\n```\n\n**Wiring check:**\n```bash\n# Imports database/service clients\ngrep -E \"^import.*prisma|^import.*db|^import.*client\" \"$route_path\"\n\n# Actually uses request body (for POST/PUT)\ngrep -E \"req\\.json\\(\\)|req\\.body|request\\.json\\(\\)\" \"$route_path\"\n\n# Validates input (not just trusting request)\ngrep -E \"schema\\.parse|validate|zod|yup|joi\" \"$route_path\"\n```\n\n**Functional verification (human or automated):**\n- Does GET return real data from database?\n- Does POST actually create a record?\n- Does error response have correct status code?\n- Are auth checks actually enforced?\n\n</api_routes>\n\n<database_schema>\n\n## Database Schema (Prisma / Drizzle / SQL)\n\n**Existence check:**\n```bash\n# Schema file exists\n[ -f \"prisma/schema.prisma\" ] || [ -f \"drizzle/schema.ts\" ] || [ -f \"src/db/schema.sql\" ]\n\n# Model/table is defined\ngrep -E \"^model $model_name|CREATE TABLE $table_name|export const $table_name\" \"$schema_path\"\n```\n\n**Substantive check:**\n```bash\n# Has expected fields (not just id)\ngrep -A 20 \"model $model_name\" \"$schema_path\" | grep -E \"^\\s+\\w+\\s+\\w+\"\n\n# Has relationships if expected\ngrep -E \"@relation|REFERENCES|FOREIGN KEY\" \"$schema_path\"\n\n# Has appropriate field types (not all String)\ngrep -A 20 \"model $model_name\" \"$schema_path\" | grep -E \"Int|DateTime|Boolean|Float|Decimal|Json\"\n```\n\n**Stub patterns specific to schemas:**\n```prisma\n// RED FLAGS - These are stubs:\nmodel User {\n  id String @id\n  // TODO: add fields\n}\n\nmodel Message {\n  id        String @id\n  content   String  // Only one real field\n}\n\n// Missing critical fields:\nmodel Order {\n  id     String @id\n  // No: userId, items, total, status, createdAt\n}\n```\n\n**Wiring check:**\n```bash\n# Migrations exist and are applied\nls prisma/migrations/ 2>/dev/null | wc -l  # Should be > 0\nnpx prisma migrate status 2>/dev/null | grep -v \"pending\"\n\n# Client is generated\n[ -d \"node_modules/.prisma/client\" ]\n```\n\n**Functional verification:**\n```bash\n# Can query the table (automated)\nnpx prisma db execute --stdin <<< \"SELECT COUNT(*) FROM $table_name\"\n```\n\n</database_schema>\n\n<hooks_utilities>\n\n## Custom Hooks and Utilities\n\n**Existence check:**\n```bash\n# File exists and exports function\n[ -f \"$hook_path\" ] && grep -E \"export (default )?(function|const)\" \"$hook_path\"\n```\n\n**Substantive check:**\n```bash\n# Hook uses React hooks (for custom hooks)\ngrep -E \"useState|useEffect|useCallback|useMemo|useRef|useContext\" \"$hook_path\"\n\n# Has meaningful return value\ngrep -E \"return \\{|return \\[\" \"$hook_path\"\n\n# More than trivial length\n[ $(wc -l < \"$hook_path\") -gt 10 ]\n```\n\n**Stub patterns specific to hooks:**\n```typescript\n// RED FLAGS - These are stubs:\nexport function useAuth() {\n  return { user: null, login: () => {}, logout: () => {} }\n}\n\nexport function useCart() {\n  const [items, setItems] = useState([])\n  return { items, addItem: () => console.log('add'), removeItem: () => {} }\n}\n\n// Hardcoded return:\nexport function useUser() {\n  return { name: \"Test User\", email: \"test@example.com\" }\n}\n```\n\n**Wiring check:**\n```bash\n# Hook is actually imported somewhere\ngrep -r \"import.*$hook_name\" src/ --include=\"*.tsx\" --include=\"*.ts\" | grep -v \"$hook_path\"\n\n# Hook is actually called\ngrep -r \"$hook_name()\" src/ --include=\"*.tsx\" --include=\"*.ts\" | grep -v \"$hook_path\"\n```\n\n</hooks_utilities>\n\n<environment_config>\n\n## Environment Variables and Configuration\n\n**Existence check:**\n```bash\n# .env file exists\n[ -f \".env\" ] || [ -f \".env.local\" ]\n\n# Required variable is defined\ngrep -E \"^$VAR_NAME=\" .env .env.local 2>/dev/null\n```\n\n**Substantive check:**\n```bash\n# Variable has actual value (not placeholder)\ngrep -E \"^$VAR_NAME=.+\" .env .env.local 2>/dev/null | grep -v \"your-.*-here|xxx|placeholder|TODO\" -i\n\n# Value looks valid for type:\n# - URLs should start with http\n# - Keys should be long enough\n# - Booleans should be true/false\n```\n\n**Stub patterns specific to env:**\n```bash\n# RED FLAGS - These are stubs:\nDATABASE_URL=your-database-url-here\nSTRIPE_SECRET_KEY=sk_test_xxx\nAPI_KEY=placeholder\nNEXT_PUBLIC_API_URL=http://localhost:3000  # Still pointing to localhost in prod\n```\n\n**Wiring check:**\n```bash\n# Variable is actually used in code\ngrep -r \"process\\.env\\.$VAR_NAME|env\\.$VAR_NAME\" src/ --include=\"*.ts\" --include=\"*.tsx\"\n\n# Variable is in validation schema (if using zod/etc for env)\ngrep -E \"$VAR_NAME\" src/env.ts src/env.mjs 2>/dev/null\n```\n\n</environment_config>\n\n<wiring_verification>\n\n## Wiring Verification Patterns\n\nWiring verification checks that components actually communicate. This is where most stubs hide.\n\n### Pattern: Component → API\n\n**Check:** Does the component actually call the API?\n\n```bash\n# Find the fetch/axios call\ngrep -E \"fetch\\(['\\\"].*$api_path|axios\\.(get|post).*$api_path\" \"$component_path\"\n\n# Verify it's not commented out\ngrep -E \"fetch\\(|axios\\.\" \"$component_path\" | grep -v \"^.*//.*fetch\"\n\n# Check the response is used\ngrep -E \"await.*fetch|\\.then\\(|setData|setState\" \"$component_path\"\n```\n\n**Red flags:**\n```typescript\n// Fetch exists but response ignored:\nfetch('/api/messages')  // No await, no .then, no assignment\n\n// Fetch in comment:\n// fetch('/api/messages').then(r => r.json()).then(setMessages)\n\n// Fetch to wrong endpoint:\nfetch('/api/message')  // Typo - should be /api/messages\n```\n\n### Pattern: API → Database\n\n**Check:** Does the API route actually query the database?\n\n```bash\n# Find the database call\ngrep -E \"prisma\\.$model|db\\.query|Model\\.find\" \"$route_path\"\n\n# Verify it's awaited\ngrep -E \"await.*prisma|await.*db\\.\" \"$route_path\"\n\n# Check result is returned\ngrep -E \"return.*json.*data|res\\.json.*result\" \"$route_path\"\n```\n\n**Red flags:**\n```typescript\n// Query exists but result not returned:\nawait prisma.message.findMany()\nreturn Response.json({ ok: true })  // Returns static, not query result\n\n// Query not awaited:\nconst messages = prisma.message.findMany()  // Missing await\nreturn Response.json(messages)  // Returns Promise, not data\n```\n\n### Pattern: Form → Handler\n\n**Check:** Does the form submission actually do something?\n\n```bash\n# Find onSubmit handler\ngrep -E \"onSubmit=\\{|handleSubmit\" \"$component_path\"\n\n# Check handler has content\ngrep -A 10 \"onSubmit.*=\" \"$component_path\" | grep -E \"fetch|axios|mutate|dispatch\"\n\n# Verify not just preventDefault\ngrep -A 5 \"onSubmit\" \"$component_path\" | grep -v \"only.*preventDefault\" -i\n```\n\n**Red flags:**\n```typescript\n// Handler only prevents default:\nonSubmit={(e) => e.preventDefault()}\n\n// Handler only logs:\nconst handleSubmit = (data) => {\n  console.log(data)\n}\n\n// Handler is empty:\nonSubmit={() => {}}\n```\n\n### Pattern: State → Render\n\n**Check:** Does the component render state, not hardcoded content?\n\n```bash\n# Find state usage in JSX\ngrep -E \"\\{.*messages.*\\}|\\{.*data.*\\}|\\{.*items.*\\}\" \"$component_path\"\n\n# Check map/render of state\ngrep -E \"\\.map\\(|\\.filter\\(|\\.reduce\\(\" \"$component_path\"\n\n# Verify dynamic content\ngrep -E \"\\{[a-zA-Z_]+\\.\" \"$component_path\"  # Variable interpolation\n```\n\n**Red flags:**\n```tsx\n// Hardcoded instead of state:\nreturn <div>\n  <p>Message 1</p>\n  <p>Message 2</p>\n</div>\n\n// State exists but not rendered:\nconst [messages, setMessages] = useState([])\nreturn <div>No messages</div>  // Always shows \"no messages\"\n\n// Wrong state rendered:\nconst [messages, setMessages] = useState([])\nreturn <div>{otherData.map(...)}</div>  // Uses different data\n```\n\n</wiring_verification>\n\n<verification_checklist>\n\n## Quick Verification Checklist\n\nFor each artifact type, run through this checklist:\n\n### Component Checklist\n- [ ] File exists at expected path\n- [ ] Exports a function/const component\n- [ ] Returns JSX (not null/empty)\n- [ ] No placeholder text in render\n- [ ] Uses props or state (not static)\n- [ ] Event handlers have real implementations\n- [ ] Imports resolve correctly\n- [ ] Used somewhere in the app\n\n### API Route Checklist\n- [ ] File exists at expected path\n- [ ] Exports HTTP method handlers\n- [ ] Handlers have more than 5 lines\n- [ ] Queries database or service\n- [ ] Returns meaningful response (not empty/placeholder)\n- [ ] Has error handling\n- [ ] Validates input\n- [ ] Called from frontend\n\n### Schema Checklist\n- [ ] Model/table defined\n- [ ] Has all expected fields\n- [ ] Fields have appropriate types\n- [ ] Relationships defined if needed\n- [ ] Migrations exist and applied\n- [ ] Client generated\n\n### Hook/Utility Checklist\n- [ ] File exists at expected path\n- [ ] Exports function\n- [ ] Has meaningful implementation (not empty returns)\n- [ ] Used somewhere in the app\n- [ ] Return values consumed\n\n### Wiring Checklist\n- [ ] Component → API: fetch/axios call exists and uses response\n- [ ] API → Database: query exists and result returned\n- [ ] Form → Handler: onSubmit calls API/mutation\n- [ ] State → Render: state variables appear in JSX\n\n</verification_checklist>\n\n<automated_verification_script>\n\n## Automated Verification Approach\n\nFor the verification subagent, use this pattern:\n\n```bash\n# 1. Check existence\ncheck_exists() {\n  [ -f \"$1\" ] && echo \"EXISTS: $1\" || echo \"MISSING: $1\"\n}\n\n# 2. Check for stub patterns\ncheck_stubs() {\n  local file=\"$1\"\n  local stubs=$(grep -c -E \"TODO|FIXME|placeholder|not implemented\" \"$file\" 2>/dev/null || echo 0)\n  [ \"$stubs\" -gt 0 ] && echo \"STUB_PATTERNS: $stubs in $file\"\n}\n\n# 3. Check wiring (component calls API)\ncheck_wiring() {\n  local component=\"$1\"\n  local api_path=\"$2\"\n  grep -q \"$api_path\" \"$component\" && echo \"WIRED: $component → $api_path\" || echo \"NOT_WIRED: $component → $api_path\"\n}\n\n# 4. Check substantive (more than N lines, has expected patterns)\ncheck_substantive() {\n  local file=\"$1\"\n  local min_lines=\"$2\"\n  local pattern=\"$3\"\n  local lines=$(wc -l < \"$file\" 2>/dev/null || echo 0)\n  local has_pattern=$(grep -c -E \"$pattern\" \"$file\" 2>/dev/null || echo 0)\n  [ \"$lines\" -ge \"$min_lines\" ] && [ \"$has_pattern\" -gt 0 ] && echo \"SUBSTANTIVE: $file\" || echo \"THIN: $file ($lines lines, $has_pattern matches)\"\n}\n```\n\nRun these checks against each must-have artifact. Aggregate results into VERIFICATION.md.\n\n</automated_verification_script>\n\n<human_verification_triggers>\n\n## When to Require Human Verification\n\nSome things can't be verified programmatically. Flag these for human testing:\n\n**Always human:**\n- Visual appearance (does it look right?)\n- User flow completion (can you actually do the thing?)\n- Real-time behavior (WebSocket, SSE)\n- External service integration (Stripe, email sending)\n- Error message clarity (is the message helpful?)\n- Performance feel (does it feel fast?)\n\n**Human if uncertain:**\n- Complex wiring that grep can't trace\n- Dynamic behavior depending on state\n- Edge cases and error states\n- Mobile responsiveness\n- Accessibility\n\n**Format for human verification request:**\n```markdown\n## Human Verification Required\n\n### 1. Chat message sending\n**Test:** Type a message and click Send\n**Expected:** Message appears in list, input clears\n**Check:** Does message persist after refresh?\n\n### 2. Error handling\n**Test:** Disconnect network, try to send\n**Expected:** Error message appears, message not lost\n**Check:** Can retry after reconnect?\n```\n\n</human_verification_triggers>\n\n<checkpoint_automation_reference>\n\n## Pre-Checkpoint Automation\n\nFor automation-first checkpoint patterns, server lifecycle management, CLI installation handling, and error recovery protocols, see:\n\n**@./.gemini/get-shit-done/references/checkpoints.md** → `<automation_reference>` section\n\nKey principles:\n- Claude sets up verification environment BEFORE presenting checkpoints\n- Users never run CLI commands (visit URLs only)\n- Server lifecycle: start before checkpoint, handle port conflicts, keep running for duration\n- CLI installation: auto-install where safe, checkpoint for user choice otherwise\n- Error handling: fix broken environment before checkpoint, never present checkpoint with failed setup\n\n</checkpoint_automation_reference>\n"
