prompt = "# Model Profiles\n\nModel profiles control which Claude model each GSD agent uses. This allows balancing quality vs token spend.\n\n## Profile Definitions\n\n| Agent | `quality` | `balanced` | `budget` |\n|-------|-----------|------------|----------|\n| gsd-planner | opus | opus | sonnet |\n| gsd-roadmapper | opus | sonnet | sonnet |\n| gsd-executor | opus | sonnet | sonnet |\n| gsd-phase-researcher | opus | sonnet | haiku |\n| gsd-project-researcher | opus | sonnet | haiku |\n| gsd-research-synthesizer | sonnet | sonnet | haiku |\n| gsd-debugger | opus | sonnet | sonnet |\n| gsd-codebase-mapper | sonnet | haiku | haiku |\n| gsd-verifier | sonnet | sonnet | haiku |\n| gsd-plan-checker | sonnet | sonnet | haiku |\n| gsd-integration-checker | sonnet | sonnet | haiku |\n\n## Profile Philosophy\n\n**quality** - Maximum reasoning power\n- Opus for all decision-making agents\n- Sonnet for read-only verification\n- Use when: quota available, critical architecture work\n\n**balanced** (default) - Smart allocation\n- Opus only for planning (where architecture decisions happen)\n- Sonnet for execution and research (follows explicit instructions)\n- Sonnet for verification (needs reasoning, not just pattern matching)\n- Use when: normal development, good balance of quality and cost\n\n**budget** - Minimal Opus usage\n- Sonnet for anything that writes code\n- Haiku for research and verification\n- Use when: conserving quota, high-volume work, less critical phases\n\n## Resolution Logic\n\nOrchestrators resolve model before spawning:\n\n```\n1. Read .planning/config.json\n2. Get model_profile (default: \"balanced\")\n3. Look up agent in table above\n4. Pass model parameter to Task call\n```\n\n## Switching Profiles\n\nRuntime: `/gsd:set-profile <profile>`\n\nPer-project default: Set in `.planning/config.json`:\n```json\n{\n  \"model_profile\": \"balanced\"\n}\n```\n\n## Design Rationale\n\n**Why Opus for gsd-planner?**\nPlanning involves architecture decisions, goal decomposition, and task design. This is where model quality has the highest impact.\n\n**Why Sonnet for gsd-executor?**\nExecutors follow explicit PLAN.md instructions. The plan already contains the reasoning; execution is implementation.\n\n**Why Sonnet (not Haiku) for verifiers in balanced?**\nVerification requires goal-backward reasoning - checking if code *delivers* what the phase promised, not just pattern matching. Sonnet handles this well; Haiku may miss subtle gaps.\n\n**Why Haiku for gsd-codebase-mapper?**\nRead-only exploration and pattern extraction. No reasoning required, just structured output from file contents.\n"
