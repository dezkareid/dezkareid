prompt = "<overview>\nGit integration for GSD framework.\n</overview>\n\n<core_principle>\n\n**Commit outcomes, not process.**\n\nThe git log should read like a changelog of what shipped, not a diary of planning activity.\n</core_principle>\n\n<commit_points>\n\n| Event                   | Commit? | Why                                              |\n| ----------------------- | ------- | ------------------------------------------------ |\n| BRIEF + ROADMAP created | YES     | Project initialization                           |\n| PLAN.md created         | NO      | Intermediate - commit with plan completion       |\n| RESEARCH.md created     | NO      | Intermediate                                     |\n| DISCOVERY.md created    | NO      | Intermediate                                     |\n| **Task completed**      | YES     | Atomic unit of work (1 commit per task)         |\n| **Plan completed**      | YES     | Metadata commit (SUMMARY + STATE + ROADMAP)     |\n| Handoff created         | YES     | WIP state preserved                              |\n\n</commit_points>\n\n<git_check>\n\n```bash\n[ -d .git ] && echo \"GIT_EXISTS\" || echo \"NO_GIT\"\n```\n\nIf NO_GIT: Run `git init` silently. GSD projects always get their own repo.\n</git_check>\n\n<commit_formats>\n\n<format name=\"initialization\">\n## Project Initialization (brief + roadmap together)\n\n```\ndocs: initialize [project-name] ([N] phases)\n\n[One-liner from PROJECT.md]\n\nPhases:\n1. [phase-name]: [goal]\n2. [phase-name]: [goal]\n3. [phase-name]: [goal]\n```\n\nWhat to commit:\n\n```bash\nnode ./.gemini/get-shit-done/bin/gsd-tools.js commit \"docs: initialize [project-name] ([N] phases)\" --files .planning/\n```\n\n</format>\n\n<format name=\"task-completion\">\n## Task Completion (During Plan Execution)\n\nEach task gets its own commit immediately after completion.\n\n```\n{type}({phase}-{plan}): {task-name}\n\n- [Key change 1]\n- [Key change 2]\n- [Key change 3]\n```\n\n**Commit types:**\n- `feat` - New feature/functionality\n- `fix` - Bug fix\n- `test` - Test-only (TDD RED phase)\n- `refactor` - Code cleanup (TDD REFACTOR phase)\n- `perf` - Performance improvement\n- `chore` - Dependencies, config, tooling\n\n**Examples:**\n\n```bash\n# Standard task\ngit add src/api/auth.ts src/types/user.ts\ngit commit -m \"feat(08-02): create user registration endpoint\n\n- POST /auth/register validates email and password\n- Checks for duplicate users\n- Returns JWT token on success\n\"\n\n# TDD task - RED phase\ngit add src/__tests__/jwt.test.ts\ngit commit -m \"test(07-02): add failing test for JWT generation\n\n- Tests token contains user ID claim\n- Tests token expires in 1 hour\n- Tests signature verification\n\"\n\n# TDD task - GREEN phase\ngit add src/utils/jwt.ts\ngit commit -m \"feat(07-02): implement JWT generation\n\n- Uses jose library for signing\n- Includes user ID and expiry claims\n- Signs with HS256 algorithm\n\"\n```\n\n</format>\n\n<format name=\"plan-completion\">\n## Plan Completion (After All Tasks Done)\n\nAfter all tasks committed, one final metadata commit captures plan completion.\n\n```\ndocs({phase}-{plan}): complete [plan-name] plan\n\nTasks completed: [N]/[N]\n- [Task 1 name]\n- [Task 2 name]\n- [Task 3 name]\n\nSUMMARY: .planning/phases/XX-name/{phase}-{plan}-SUMMARY.md\n```\n\nWhat to commit:\n\n```bash\nnode ./.gemini/get-shit-done/bin/gsd-tools.js commit \"docs({phase}-{plan}): complete [plan-name] plan\" --files .planning/phases/XX-name/{phase}-{plan}-PLAN.md .planning/phases/XX-name/{phase}-{plan}-SUMMARY.md .planning/STATE.md .planning/ROADMAP.md\n```\n\n**Note:** Code files NOT included - already committed per-task.\n\n</format>\n\n<format name=\"handoff\">\n## Handoff (WIP)\n\n```\nwip: [phase-name] paused at task [X]/[Y]\n\nCurrent: [task name]\n[If blocked:] Blocked: [reason]\n```\n\nWhat to commit:\n\n```bash\nnode ./.gemini/get-shit-done/bin/gsd-tools.js commit \"wip: [phase-name] paused at task [X]/[Y]\" --files .planning/\n```\n\n</format>\n</commit_formats>\n\n<example_log>\n\n**Old approach (per-plan commits):**\n```\na7f2d1 feat(checkout): Stripe payments with webhook verification\n3e9c4b feat(products): catalog with search, filters, and pagination\n8a1b2c feat(auth): JWT with refresh rotation using jose\n5c3d7e feat(foundation): Next.js 15 + Prisma + Tailwind scaffold\n2f4a8d docs: initialize ecommerce-app (5 phases)\n```\n\n**New approach (per-task commits):**\n```\n# Phase 04 - Checkout\n1a2b3c docs(04-01): complete checkout flow plan\n4d5e6f feat(04-01): add webhook signature verification\n7g8h9i feat(04-01): implement payment session creation\n0j1k2l feat(04-01): create checkout page component\n\n# Phase 03 - Products\n3m4n5o docs(03-02): complete product listing plan\n6p7q8r feat(03-02): add pagination controls\n9s0t1u feat(03-02): implement search and filters\n2v3w4x feat(03-01): create product catalog schema\n\n# Phase 02 - Auth\n5y6z7a docs(02-02): complete token refresh plan\n8b9c0d feat(02-02): implement refresh token rotation\n1e2f3g test(02-02): add failing test for token refresh\n4h5i6j docs(02-01): complete JWT setup plan\n7k8l9m feat(02-01): add JWT generation and validation\n0n1o2p chore(02-01): install jose library\n\n# Phase 01 - Foundation\n3q4r5s docs(01-01): complete scaffold plan\n6t7u8v feat(01-01): configure Tailwind and globals\n9w0x1y feat(01-01): set up Prisma with database\n2z3a4b feat(01-01): create Next.js 15 project\n\n# Initialization\n5c6d7e docs: initialize ecommerce-app (5 phases)\n```\n\nEach plan produces 2-4 commits (tasks + metadata). Clear, granular, bisectable.\n\n</example_log>\n\n<anti_patterns>\n\n**Still don't commit (intermediate artifacts):**\n- PLAN.md creation (commit with plan completion)\n- RESEARCH.md (intermediate)\n- DISCOVERY.md (intermediate)\n- Minor planning tweaks\n- \"Fixed typo in roadmap\"\n\n**Do commit (outcomes):**\n- Each task completion (feat/fix/test/refactor)\n- Plan completion metadata (docs)\n- Project initialization (docs)\n\n**Key principle:** Commit working code and shipped outcomes, not planning process.\n\n</anti_patterns>\n\n<commit_strategy_rationale>\n\n## Why Per-Task Commits?\n\n**Context engineering for AI:**\n- Git history becomes primary context source for future Claude sessions\n- `git log --grep=\"{phase}-{plan}\"` shows all work for a plan\n- `git diff <hash>^..<hash>` shows exact changes per task\n- Less reliance on parsing SUMMARY.md = more context for actual work\n\n**Failure recovery:**\n- Task 1 committed ✅, Task 2 failed ❌\n- Claude in next session: sees task 1 complete, can retry task 2\n- Can `git reset --hard` to last successful task\n\n**Debugging:**\n- `git bisect` finds exact failing task, not just failing plan\n- `git blame` traces line to specific task context\n- Each commit is independently revertable\n\n**Observability:**\n- Solo developer + Claude workflow benefits from granular attribution\n- Atomic commits are git best practice\n- \"Commit noise\" irrelevant when consumer is Claude, not humans\n\n</commit_strategy_rationale>\n"
